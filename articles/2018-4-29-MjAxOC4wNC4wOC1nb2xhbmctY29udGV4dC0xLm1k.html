
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Golang中的context之传值（一） - Chyroc的博客</title>
<meta property="og:title" content="blog.chyroc.cn" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Chyroc的博客" />
<meta property="og:description" content="Chyroc的博客" />
<link rel="canonical" href="blog.chyroc.cn" />
<meta property="og:url" content="blog.chyroc.cn" />
<meta property="og:site_name" content="blog.chyroc.cn" />
<script type="application/ld+json">
{"name":"blog.chyroc.cn","description":"Chyroc的博客","author":"Chyroc","@type":"WebSite","url":"blog.chyroc.cn","image":null,"publisher":null,"headline":"blog.chyroc.cn","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>


<link href="https://blog.chyroc.cn/assets/css/style.css" rel="stylesheet">
</head>
<body>
<div class="container-lg px-3 my-5 markdown-body">

<h1>
<a id="user-content-golang中的context之传值一" class="anchor" href="#golang%E4%B8%AD%E7%9A%84context%E4%B9%8B%E4%BC%A0%E5%80%BC%E4%B8%80" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Golang中的context之传值（一）</h1>
<blockquote>
<p>前几天在工作中使用context的时候，对于metadata和context.Value有一些疑惑，顺便探索了一下go的context，在这里分享一下</p>
</blockquote>
<blockquote>
<p>现在是2018-04-29 19:49，正在北京开往家的动车上，窗外已经是黑黑的一片了，11点到家，写一会文章吧</p>
</blockquote>
<h2>
<a id="user-content-context包" class="anchor" href="#context%E5%8C%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>context包</h2>
<p>这里说的context包指的是golang(1.7+)中的标准库context，文档在这里：<a href="https://godoc.org/context" rel="nofollow">https://godoc.org/context</a> 。</p>
<p>context包定义了Context类型，他可以在携带deadlines和cancelatin信号，也可以携带其他的请求值。</p>
<p>发送到server的请求应该创建一个context，服务器处理请求的时候也应该接受一个context。在程序的函数调用链中，必须传递context，也可以基于一个context，使用WithCancel, WithDeadline, WithTimeout, or WithValue等函数创建一个新的context传递下去。当一个context被canceled的时候，那么所有通过改context派生的context都应该被cancel</p>
<p>WithCancel, WithDeadline, and WithTimeout这三个函数使用一个context(the parent) 作为参数，然后创建一个新的context（the child）和CancelFunc函数。调用CancelFunc函数将会取消该child和他的children，移除parent到child的应用，然后停止任何相关的timeers。吐过调用这个函数失败的话，会导致child和他的children知道parent cancel的时候或者timer fired的时候才会取消。go vet工具会检查CancelFuncs对否在所有的控制分支上使用了。</p>
<p>context的使用规则</p>
<ul>
<li>context应该作为函数参数传递，而不是struct的一个field</li>
<li>context应该是函数的第一个参数</li>
<li>不要传递nil context，即使是不使用，如果不知道用啥，用 context.TODO 吧</li>
<li>只使用context传递请求上下文，而不是为了传递可选参数</li>
<li>context可能会被同一个函数在不同的goroutine中使用，他是并发安全的</li>
</ul>
<h2>
<a id="user-content-context接口" class="anchor" href="#context%E6%8E%A5%E5%8F%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>context接口</h2>
<p>以下是context的接口定义</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">type</span> <span class="pl-v">Context</span> <span class="pl-k">interface</span> {
    <span class="pl-c"><span class="pl-c">//</span> 返回当前context应该被cancel的时间</span>
    <span class="pl-c"><span class="pl-c">//</span> 如果 ok==false 的话，那么当前context没有deadline</span>
    <span class="pl-c1">Deadline</span>() (deadline time.<span class="pl-smi">Time</span>, ok <span class="pl-k">bool</span>)

    <span class="pl-c"><span class="pl-c">//</span> 返回了一个chan，当 当前context被cancel的时候，这个chan就会被close</span>
    <span class="pl-c"><span class="pl-c">//</span> 如果这个context永远也不会被cancel的时候，会返回一个nil</span>
    <span class="pl-c"><span class="pl-c">//</span></span>
    <span class="pl-c"><span class="pl-c">//</span> WithCancel会在cancel的遍历Done</span>
    <span class="pl-c"><span class="pl-c">//</span> WithDeadline</span>
    <span class="pl-c"><span class="pl-c">//</span> WithTimeout</span>
    <span class="pl-c"><span class="pl-c">//</span></span>
    <span class="pl-c"><span class="pl-c">//</span> Done是为了在select中使用提供的</span>
    <span class="pl-c"><span class="pl-c">//</span></span>
    <span class="pl-c"><span class="pl-c">//</span>  // Stream generates values with DoSomething and sends them to out</span>
    <span class="pl-c"><span class="pl-c">//</span>  // until DoSomething returns an error or ctx.Done is closed.</span>
    <span class="pl-c"><span class="pl-c">//</span>  func Stream(ctx context.Context, out chan&lt;- Value) error {</span>
    <span class="pl-c"><span class="pl-c">//</span>          for {</span>
    <span class="pl-c"><span class="pl-c">//</span>                  v, err := DoSomething(ctx)</span>
    <span class="pl-c"><span class="pl-c">//</span>                  if err != nil {</span>
    <span class="pl-c"><span class="pl-c">//</span>                          return err</span>
    <span class="pl-c"><span class="pl-c">//</span>                  }</span>
    <span class="pl-c"><span class="pl-c">//</span>                  select {</span>
    <span class="pl-c"><span class="pl-c">//</span>                  case &lt;-ctx.Done():</span>
    <span class="pl-c"><span class="pl-c">//</span>                          return ctx.Err()</span>
    <span class="pl-c"><span class="pl-c">//</span>                  case out &lt;- v:</span>
    <span class="pl-c"><span class="pl-c">//</span>                  }</span>
    <span class="pl-c"><span class="pl-c">//</span>          }</span>
    <span class="pl-c"><span class="pl-c">//</span>  }</span>
    <span class="pl-c"><span class="pl-c">//</span></span>
    <span class="pl-c"><span class="pl-c">//</span> See https://blog.golang.org/pipelines for more examples of how to use</span>
    <span class="pl-c"><span class="pl-c">//</span> a Done channel for cancelation.</span>
    <span class="pl-c1">Done</span>() <span class="pl-k">&lt;-</span><span class="pl-k">chan</span> <span class="pl-k">struct</span>{}

    <span class="pl-c"><span class="pl-c">//</span> 如果Done还没有被close，返回nil</span>
    <span class="pl-c"><span class="pl-c">//</span> 如果Done已经被clode了，返回一个non-nil的err，有几个err：</span>
    <span class="pl-c"><span class="pl-c">//</span> Canceled： context是被cancel的</span>
    <span class="pl-c"><span class="pl-c">//</span> DeadlineExceeded： context的deadline过了</span>
    <span class="pl-c"><span class="pl-c">//</span> 如果Err返回了一个non-nil，那么以后返回的结果也都是一样的</span>
    <span class="pl-c1">Err</span>() <span class="pl-k">error</span>

    <span class="pl-c"><span class="pl-c">//</span> 返回指定的key的值，如果没有，返回nil</span>
    <span class="pl-c"><span class="pl-c">//</span></span>
    <span class="pl-c"><span class="pl-c">//</span> 一个key指定了context中唯一的value。</span>
    <span class="pl-c"><span class="pl-c">//</span> key可以是任何可以比较的类型，(golint不允许使用string)</span>
    <span class="pl-c"><span class="pl-c">//</span> 各个包应该定义自己的非导出的类型所谓key，以避免重叠</span>
    <span class="pl-c1">Value</span>(key <span class="pl-k">interface</span>{}) <span class="pl-k">interface</span>{}
}</pre></div>
<h2>
<a id="user-content-context是如何实现k-v键值对存储的" class="anchor" href="#context%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0k-v%E9%94%AE%E5%80%BC%E5%AF%B9%E5%AD%98%E5%82%A8%E7%9A%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>context是如何实现k-v键值对存储的</h2>
<h3>
<a id="user-content-什么是contextk-v存储" class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AFcontextk-v%E5%AD%98%E5%82%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>什么是contextk-v存储</h3>
<p>通过下面这样的代码可以在goroutine之间安全的传递数据</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">type</span> key = <span class="pl-k">struct</span>{}
<span class="pl-smi">ctx</span> <span class="pl-k">:=</span> context.<span class="pl-c1">Background</span>()
ctx = context.<span class="pl-c1">WithValue</span>(ctx, key{}, <span class="pl-s"><span class="pl-pds">"</span>this is value<span class="pl-pds">"</span></span>)
fmt.<span class="pl-c1">Printf</span>(<span class="pl-s"><span class="pl-pds">"</span>value: <span class="pl-c1">%v</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, ctx.<span class="pl-c1">Value</span>(key{}))</pre></div>
<h3>
<a id="user-content-简析" class="anchor" href="#%E7%AE%80%E6%9E%90" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>简析</h3>
<p>context值的实现和cancel等的实现是基于不同的struct的，这些struct都和接口Context组合了，所以都<strong>实现</strong>了接口Context（参见<a href="http://blog.chyroc.cn/articles/2017-8-3-247632972.html" rel="nofollow">这篇我的博文</a>）</p>
<p>这种思想是可以借鉴的，即先定义一个interface，然后不同的struct组合这个interface，然后实现不同的方法</p>
<p>context的k-v对存储是一个树状的结构，每个节点都存储一对k-v，并指向父context</p>
<h3>
<a id="user-content-代码解析" class="anchor" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>代码解析</h3>
<p>下面结合k-v实现的代码看一下</p>
<div class="highlight highlight-source-go"><pre><span class="pl-c"><span class="pl-c">//</span> 定义存储k-v的struct，是一个树结构</span>
<span class="pl-k">type</span> valueCtx <span class="pl-k">struct</span> {
    <span class="pl-v">Context</span>
    key, val <span class="pl-k">interface</span>{}
}

<span class="pl-c"><span class="pl-c">//</span> String接口</span>
<span class="pl-c"><span class="pl-c">//</span> 其中的c.Context是通过`%v`格式化的，所以这个函数实际上是一个递归函数</span>
<span class="pl-c"><span class="pl-c">//</span> 这里使用%v作为递归的方法而不是c.Context.String()，是因为Context接口没有定义String方法，而valueCtx没有定义，这一点值得学习</span>
<span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">c</span> *<span class="pl-v">valueCtx</span>) <span class="pl-en">String</span></span>() <span class="pl-v">string</span> {
    <span class="pl-k">return</span> fmt.<span class="pl-c1">Sprintf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%v</span>.WithValue(<span class="pl-c1">%#v</span>, <span class="pl-c1">%#v</span>)<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, c.<span class="pl-smi">Context</span>, c.<span class="pl-smi">key</span>, c.<span class="pl-smi">val</span>)
}

<span class="pl-c"><span class="pl-c">//</span> 取值方法</span>
<span class="pl-c"><span class="pl-c">//</span> 先判断当前context中是否有该存储的值</span>
<span class="pl-c"><span class="pl-c">//</span> 没有就使用父context取，也是一个递归函数</span>
<span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">c</span> *<span class="pl-v">valueCtx</span>) <span class="pl-en">Value</span></span>(<span class="pl-v">key</span> <span class="pl-v">interface</span>{}) <span class="pl-v">interface</span>{} {
    <span class="pl-k">if</span> c.<span class="pl-smi">key</span> == key {
        <span class="pl-k">return</span> c.<span class="pl-smi">val</span>
    }
    <span class="pl-k">return</span> c.<span class="pl-smi">Context</span>.<span class="pl-c1">Value</span>(key)
}

<span class="pl-c"><span class="pl-c">//</span> 赋值方法</span>
<span class="pl-c"><span class="pl-c">//</span> 实际上是返回一个struct，这个struct里面有key和val的field，作为k-v的存储载体</span>
<span class="pl-c"><span class="pl-c">//</span> 然后为了保留意见设置的数据，需要把老context传下去</span>
<span class="pl-c"><span class="pl-c">//</span> 所以大概是这么个格式：{{{context.TODO(), key1, val1}, key2, val2}, key3, val3}</span>
<span class="pl-c"><span class="pl-c">//</span> 所以如果在同一个key上设置了两个值，那么旧的值永远不会取出来，因为会先取到后设置的值；所以也可以直接理解为一个map（实际上复杂度不是O(1)的）</span>
<span class="pl-k">func</span> <span class="pl-en">WithValue</span>(<span class="pl-v">parent</span> <span class="pl-v">Context</span>, <span class="pl-v">key</span>, <span class="pl-v">val</span> <span class="pl-v">interface</span>{}) <span class="pl-v">Context</span> {
    <span class="pl-k">if</span> key == <span class="pl-c1">nil</span> {
        <span class="pl-c1">panic</span>(<span class="pl-s"><span class="pl-pds">"</span>nil key<span class="pl-pds">"</span></span>)
    }

    <span class="pl-k">if</span> !reflect.<span class="pl-c1">TypeOf</span>(key).<span class="pl-c1">Comparable</span>() {
        <span class="pl-c1">panic</span>(<span class="pl-s"><span class="pl-pds">"</span>key is not comparable<span class="pl-pds">"</span></span>)
    }

    <span class="pl-k">return</span> &amp;valueCtx{parent, key, val}
}</pre></div>
<h2>
<a id="user-content-context中的value存储与medatada" class="anchor" href="#context%E4%B8%AD%E7%9A%84value%E5%AD%98%E5%82%A8%E4%B8%8Emedatada" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>context中的value存储与medatada</h2>
<p>在grpc中，client与server之间通过context传递上下文数据的时候，不能使用context.WithValue。</p>
<p>因为server端无法获取到client自定义的key（是这个key本身的原因还是grpc做了限制？）</p>
<p>那么如何在client与server之间传递数据呢？可以使用grpc提供的medadata接口:</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">package</span> main

<span class="pl-k">import</span> (
    <span class="pl-s"><span class="pl-pds">"</span>context<span class="pl-pds">"</span></span>
    <span class="pl-s"><span class="pl-pds">"</span>fmt<span class="pl-pds">"</span></span>
    <span class="pl-s"><span class="pl-pds">"</span>google.golang.org/grpc/metadata<span class="pl-pds">"</span></span>
)

<span class="pl-k">func</span> <span class="pl-en">main</span>() {
    <span class="pl-c"><span class="pl-c">//</span> client</span>
    <span class="pl-smi">md</span> <span class="pl-k">:=</span> metadata.<span class="pl-c1">Pairs</span>(
        <span class="pl-s"><span class="pl-pds">"</span>k1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>v1<span class="pl-pds">"</span></span>,
        <span class="pl-s"><span class="pl-pds">"</span>k2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>v2<span class="pl-pds">"</span></span>,
    )
    <span class="pl-smi">ctx</span> <span class="pl-k">:=</span> metadata.<span class="pl-c1">NewOutgoingContext</span>(context.<span class="pl-c1">Background</span>(), md)

    <span class="pl-c"><span class="pl-c">//</span> server</span>
    <span class="pl-smi">md2</span>, <span class="pl-smi">ok</span> <span class="pl-k">:=</span> metadata.<span class="pl-c1">FromIncomingContext</span>(ctx)
    <span class="pl-k">if</span> !ok {
        <span class="pl-c1">panic</span>(<span class="pl-s"><span class="pl-pds">"</span>no metadata<span class="pl-pds">"</span></span>)
    }

    fmt.<span class="pl-c1">Printf</span>(<span class="pl-s"><span class="pl-pds">"</span>k1 <span class="pl-c1">%v</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, md2[<span class="pl-s"><span class="pl-pds">"</span>k1<span class="pl-pds">"</span></span>])
    fmt.<span class="pl-c1">Printf</span>(<span class="pl-s"><span class="pl-pds">"</span>k2 <span class="pl-c1">%v</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, md2[<span class="pl-s"><span class="pl-pds">"</span>k2<span class="pl-pds">"</span></span>])
}</pre></div>
<p>这里使用了<code>metadata.NewOutgoingContext</code>传递数据，<code>metadata.FromIncomingContext</code>获取数据。</p>
<p>这里其实就是通过context.WithValue实现的，只不过key分别是指定的<code>mdOutgoingKey{}</code>，<code>mdIncomingKey{}</code></p>
<p><code>mdOutgoingKey{}</code>，<code>mdIncomingKey{}</code>之间的区别就是，在client端发送数据的时候选用<code>metadata.NewOutgoingContext</code>，在server接受数据的时候，选用<code>metadata.FromIncomingContext</code></p>
<h2>
<a id="user-content-参考文章" class="anchor" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>参考文章</h2>
<ul>
<li><a href="https://github.com/grpc/grpc-go/issues/156">https://github.com/grpc/grpc-go/issues/156</a></li>
<li><a href="https://talks.golang.org/2014/gotham-context.slide#1" rel="nofollow">https://talks.golang.org/2014/gotham-context.slide#1</a></li>
</ul>


</div>

</body>
</html>
