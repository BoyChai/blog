
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>golang中的testing包介绍 - Chyroc的博客</title>
<meta property="og:title" content="blog.chyroc.cn" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Chyroc的博客" />
<meta property="og:description" content="Chyroc的博客" />
<link rel="canonical" href="blog.chyroc.cn" />
<meta property="og:url" content="blog.chyroc.cn" />
<meta property="og:site_name" content="blog.chyroc.cn" />
<script type="application/ld+json">
{"name":"blog.chyroc.cn","description":"Chyroc的博客","author":"Chyroc","@type":"WebSite","url":"blog.chyroc.cn","image":null,"publisher":null,"headline":"blog.chyroc.cn","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>


<link href="https://blog.chyroc.cn/assets/css/style.css" rel="stylesheet">
</head>
<body>
<div class="container-lg px-3 my-5 markdown-body">

<h1>
<a id="user-content-golang中的testing包介绍" class="anchor" href="#golang%E4%B8%AD%E7%9A%84testing%E5%8C%85%E4%BB%8B%E7%BB%8D" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>golang中的testing包介绍</h1>
<p>testing包是go中提供自动化测试的包，和命令go test配合使用，能够自动执行匹配到的函数。</p>
<h1>
<a id="user-content-testxxx" class="anchor" href="#testxxx" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>TestXxx</h1>
<p>测试函数一般是这样的：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">TestXxx</span>(*<span class="pl-v">testing</span>.<span class="pl-v">T</span>)</pre></div>
<p>测试函数需要满足一定的条件才能被执行，就像上面的那样，以<code>Test</code>开头，然后接一个以大写字母开头的单词，函数参数是<code>*testing.T</code></p>
<p>测试函数所在的文件也需要满足一定的条件：文件名需要以<code>_test.go</code>结尾，这样的文件在<code>go build</code>的时候不会包含，但是可以在<code>go test</code>的时候调用到</p>
<h1>
<a id="user-content-benchmarkxxx" class="anchor" href="#benchmarkxxx" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BenchmarkXxx</h1>
<p>其实还有一种测试函数：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">BenchmarkXxx</span>(*<span class="pl-v">testing</span>.<span class="pl-v">B</span>)</pre></div>
<p>和上面那个<code>TestXxx</code>差不多，以<code>Benchmark</code>开头，并接一个大写字母开头的单词，函数参数是<code>*testing.B</code></p>
<p>这样的测试函数是压力测试函数，可以使用<code>go test</code>并且加上<code>-bench</code>参数的时候，被调用到</p>
<p>测试用例：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">BenchmarkHello</span>(<span class="pl-v">b</span> *<span class="pl-v">testing</span>.<span class="pl-v">B</span>) {
    <span class="pl-k">for</span> <span class="pl-smi">i</span> <span class="pl-k">:=</span> <span class="pl-c1">0</span>; i &lt; b.<span class="pl-smi">N</span>; i++ {
        fmt.<span class="pl-c1">Sprintf</span>(<span class="pl-s"><span class="pl-pds">"</span>hello<span class="pl-pds">"</span></span>)
    }
}</pre></div>
<p>压力测试函数必须运行b.N次目标代码，在压力测试函数运行期间，b.N会动态的调整，直到基准测试功能持续足够长时间以可靠地计时为止</p>
<p>压力测试函数的输出类似于：</p>
<pre><code>BenchmarkHello    10000000    282 ns/op
</code></pre>
<p>这个的意思是压力测试函数以平均282ns每次的速度运行了10000000次</p>
<p>如果压力测试函数需要setup一些操作，那么需要调用一下<code>b.ResetTimer()</code>，示例：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">BenchmarkBigLen</span>(<span class="pl-v">b</span> *<span class="pl-v">testing</span>.<span class="pl-v">B</span>) {
    <span class="pl-smi">big</span> <span class="pl-k">:=</span> <span class="pl-c1">NewBig</span>()
    b.<span class="pl-c1">ResetTimer</span>()
    <span class="pl-k">for</span> <span class="pl-smi">i</span> <span class="pl-k">:=</span> <span class="pl-c1">0</span>; i &lt; b.<span class="pl-smi">N</span>; i++ {
        big.<span class="pl-c1">Len</span>()
    }
}</pre></div>
<p>如果压力测试需要测试并发，那么需要使用到<code>RunParallel</code>函数，示例：</p>
<pre><code>func BenchmarkTemplateParallel(b *testing.B) {
    templ := template.Must(template.New("test").Parse("Hello, {{.}}!"))
    b.RunParallel(func(pb *testing.PB) {
        var buf bytes.Buffer
        for pb.Next() {
            buf.Reset()
            templ.Execute(&amp;buf, "World")
        }
    })
}
</code></pre>
<h1>
<a id="user-content-examplexxx" class="anchor" href="#examplexxx" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>ExampleXxx</h1>
<p>测试函数以<code>Example</code>开头，接一个大写字母开头的单词，没有函数参数；然后将函数内部以<code>// Output:</code>开头下面的注释和标准输出进行比较（忽略前后的空格）。</p>
<p>示例：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">ExampleSalutations</span>() {
    fmt.<span class="pl-c1">Println</span>(<span class="pl-s"><span class="pl-pds">"</span>hello, and<span class="pl-pds">"</span></span>)
    fmt.<span class="pl-c1">Println</span>(<span class="pl-s"><span class="pl-pds">"</span>goodbye<span class="pl-pds">"</span></span>)
    <span class="pl-c"><span class="pl-c">//</span> Output:</span>
    <span class="pl-c"><span class="pl-c">//</span> hello, and</span>
    <span class="pl-c"><span class="pl-c">//</span> goodbye</span>
}</pre></div>
<p>有的时候输出是无需的，比如并发的时候，这个时候就需要使用<code>// Unordered output:</code>了：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">ExamplePerm</span>() {
    <span class="pl-k">for</span> <span class="pl-smi">_</span>, <span class="pl-smi">value</span> <span class="pl-k">:=</span> <span class="pl-k">range</span> <span class="pl-c1">Perm</span>(<span class="pl-c1">4</span>) {
        fmt.<span class="pl-c1">Println</span>(value)
    }
    <span class="pl-c"><span class="pl-c">//</span> Unordered output: 4</span>
    <span class="pl-c"><span class="pl-c">//</span> 2</span>
    <span class="pl-c"><span class="pl-c">//</span> 1</span>
    <span class="pl-c"><span class="pl-c">//</span> 3</span>
    <span class="pl-c"><span class="pl-c">//</span> 0</span>
}</pre></div>
<p>使用Example的时候有一些函数命名约定：函数F，类型T，类型T上面定义的方法M</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">Example</span>() { ... }
<span class="pl-k">func</span> <span class="pl-en">ExampleF</span>() { ... }
<span class="pl-k">func</span> <span class="pl-en">ExampleT</span>() { ... }
<span class="pl-k">func</span> <span class="pl-en">ExampleT_M</span>() { ... }</pre></div>
<p>如果一个函数需要有多个Example函数，可以以下划线作为分割添加后缀</p>
<pre><code>func Example_suffix() { ... }
func ExampleF_suffix() { ... }
func ExampleT_suffix() { ... }
func ExampleT_M_suffix() { ... }
</code></pre>
<h1>
<a id="user-content-子测试和子压力测试" class="anchor" href="#%E5%AD%90%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AD%90%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>子测试和子压力测试</h1>
<p><code>*testing.T</code>和<code>*testing.B</code>的Run方法允许定义子测试和子压力测试，而不需要定义两个测试</p>
<p>示例：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">TestFoo</span>(<span class="pl-v">t</span> *<span class="pl-v">testing</span>.<span class="pl-v">T</span>) {
    <span class="pl-c"><span class="pl-c">//</span> &lt;setup code&gt;</span>
    t.<span class="pl-c1">Run</span>(<span class="pl-s"><span class="pl-pds">"</span>A=1<span class="pl-pds">"</span></span>, <span class="pl-c1">func</span>(t *testing.<span class="pl-smi">T</span>) { ... })
    t.<span class="pl-c1">Run</span>(<span class="pl-s"><span class="pl-pds">"</span>A=2<span class="pl-pds">"</span></span>, <span class="pl-c1">func</span>(t *testing.<span class="pl-smi">T</span>) { ... })
    t.<span class="pl-c1">Run</span>(<span class="pl-s"><span class="pl-pds">"</span>B=1<span class="pl-pds">"</span></span>, <span class="pl-c1">func</span>(t *testing.<span class="pl-smi">T</span>) { ... })
    <span class="pl-c"><span class="pl-c">//</span> &lt;tear-down code&gt;</span>
}</pre></div>
<p>子测试的名字需要唯一，并且和主测试的名字以<code>/</code>连接</p>
<p>可以使用<code>-run</code>或者<code>-bench</code>参数为<code>go test</code>指定需要运行的测试代码</p>
<pre><code>go test -run ''      # Run all tests.
go test -run Foo     # Run top-level tests matching "Foo", such as "TestFooBar".
go test -run Foo/A=  # For top-level tests matching "Foo", run subtests matching "A=".
go test -run /A=1    # For all top-level tests, run subtests matching "A=1".
</code></pre>
<h1>
<a id="user-content-主测试" class="anchor" href="#%E4%B8%BB%E6%B5%8B%E8%AF%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>主测试</h1>
<p>在有些测试中，需要在所有的测试之前做一些setup，在所有的测试之后做一些teardown，所以需要一个主测试来控制这些：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">TestMain</span>(<span class="pl-v">m</span> *<span class="pl-v">testing</span>.<span class="pl-v">M</span>)</pre></div>
<p>然后测试代码就不会直接运行了，而是会调用<code>TestMain</code></p>
<p>TestMain会在主goroutine中运行，并做一些setup和teardown，主测试需要调用<code>os.Exit(m.Run())</code></p>
<p>给一个例子吧：
<code>example_test.go</code></p>
<pre><code>package example

import (
	"testing"
	"os"
)

var s string

func TestA(t *testing.T) {
	t.Logf("%s", s)
}

func TestMain(m *testing.M) {
	s = "1"
	os.Exit(m.Run())
}

func TestB(t *testing.T) {
	t.Logf("%s", s)
}
</code></pre>
<p><code>go test -v $(go list ./...)</code>
输出：</p>
<pre><code>=== RUN   TestA
--- PASS: TestA (0.00s)
	a_test.go:11: 1
=== RUN   TestB
--- PASS: TestB (0.00s)
	a_test.go:20: 1
PASS
</code></pre>
<p>可以看到<code>TestMain</code>初始化了变量s，然后函数<code>TestMain</code>上面和下面的函数获取到的都是字符串1</p>
<h1>
<a id="user-content-参考" class="anchor" href="#%E5%8F%82%E8%80%83" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>参考</h1>
<ul>
<li><a href="https://golang.org/pkg/testing/" rel="nofollow">godoc: Package testing</a></li>
</ul>


</div>

</body>
</html>
