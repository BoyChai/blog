
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Begin Jekyll SEO tag v2.3.0 -->
    <title>chyroc.github.io | 基于issues的个人博客</title>
    <meta property="og:title" content="chyroc.github.io"/>
    <meta property="og:locale" content="en_US"/>
    <meta name="description" content="基于issues的个人博客"/>
    <meta property="og:description" content="基于issues的个人博客"/>
    <link rel="canonical" href="http://blog.chyroc.cn/articles/some.html"/>
    <meta property="og:url" content="http://blog.chyroc.cn/articles/some.html"/>
    <meta property="og:site_name" content="chyroc.github.io"/>
    <script type="application/ld+json">
        {"name":null,"description":"基于issues的个人博客","author":null,"@type":"WebPage","url":"http://blog.chyroc.cn/articles/some.html","image":null,"publisher":null,"headline":"chyroc.github.io","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}
    </script>
    <!-- End Jekyll SEO tag -->

    <link href="http://blog.chyroc.cn/assets/css/style.css?v=efb62de7b7525b6b14733e28358121421ac29cfd" rel="stylesheet">
</head>

<body>
<div class="container-lg px-3 my-5 markdown-body">
    <h1><a href="http://blog.chyroc.cn/">chyroc.github.io</a></h1>
<h2>
<a id="user-content-interface是一种数据类型吗" class="anchor" href="#interface%E6%98%AF%E4%B8%80%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>interface是一种数据类型吗</h2>
<p>是。</p>
<p>golang语言有四种数据类型，分别是</p>
<ul>
<li>基本类型(basic)
<ul>
<li>数字</li>
<li>字符串</li>
<li>布尔型</li>
</ul>
</li>
<li>聚合类型(aggregate)
<ul>
<li>数组</li>
<li>struct</li>
</ul>
</li>
<li>复合类型(reference)
<ul>
<li>指针</li>
<li>slice</li>
<li>map</li>
<li>函数</li>
<li>channel</li>
</ul>
</li>
<li>接口类型(interface)</li>
</ul>
<h2>
<a id="user-content-什么是方法" class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>什么是方法</h2>
<p>方法是定义在一个数据类型上面的函数，可以类比为 “类中的方法”。</p>
<p>方法和这个数据类型需要处于同一个包里，所以对于内置类型，如 int，需要从他定义一个数据类型，</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">type</span> <span class="pl-v">CountNum</span> <span class="pl-k">int</span></pre></div>
<p>然后再在这个新的数据类型上定义方法</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> (<span class="pl-v">c</span> <span class="pl-v">CountNum</span>) <span class="pl-v">Print</span> {
    fmt.<span class="pl-c1">Printf</span>(<span class="pl-s"><span class="pl-pds">"</span>CountNum is <span class="pl-c1">%d</span><span class="pl-pds">"</span></span>, i)
}</pre></div>
<p>一般是在strct上定义方法</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">type</span> <span class="pl-v">Person</span> <span class="pl-k">struct</span> {
	<span class="pl-v">Name</span> <span class="pl-k">string</span>
	<span class="pl-v">Age</span> <span class="pl-k">int</span>
}

<span class="pl-k">func</span> (<span class="pl-v">p</span> <span class="pl-v">Person</span>) <span class="pl-v">Get</span> {
  <span class="pl-k">return</span> fmt.<span class="pl-c1">Sprintf</span>(<span class="pl-s"><span class="pl-pds">"</span>Person name: <span class="pl-c1">%6s</span>, age: <span class="pl-c1">%4d</span><span class="pl-pds">"</span></span>, p.<span class="pl-smi">Name</span>, p.<span class="pl-smi">Age</span>)
}</pre></div>
<p>使用方法修改所定义的数据类型的数据</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">p</span> <span class="pl-v">Person</span>) <span class="pl-en">Set</span></span>(<span class="pl-v">name</span> <span class="pl-v">string</span>) {
	p.<span class="pl-smi">Name</span> = name
}</pre></div>
<p>如果直接这么写，是有问题的。</p>
<p>因为在golang中是参数是值传递，所以在上面这个方法里，收到了类型为<code>Person</code>的一个值的拷贝<code>p</code>，然后对<code>p</code>做了修改，是无法传递出去的。</p>
<p>所以需要改为传递指针变量：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">p</span> *<span class="pl-v">Person</span>) <span class="pl-en">Set</span></span>(<span class="pl-v">name</span> <span class="pl-v">string</span>) {
	p.<span class="pl-smi">Name</span> = name
}</pre></div>
<p>这样就可以通过指针修改原来的数据。</p>
<p>事实上，指针仍然是值传递，但是，哈哈，拷贝的指针指向的地方是不变的，是依然可以修改的。</p>
<h2>
<a id="user-content-怎么定义一个interface" class="anchor" href="#%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAinterface" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>怎么定义一个interface</h2>
<p><strong>接口的定义是方法的声明的集合，接口的实现是方法的实现的集合</strong>，所以我刚刚先说了方法。</p>
<p>和方法不一样的是，接口并不是定义在具体的类型上面的（方法是这样的）。</p>
<p>同一个接口可以在不同数据类型上实现，取决于你想要怎么搞了。</p>
<p>这里我先定义一个接口：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">type</span> <span class="pl-v">GetSet</span> <span class="pl-k">interface</span> {
    <span class="pl-c1">Get</span>() <span class="pl-k">string</span>
    <span class="pl-c1">Set</span>(<span class="pl-k">string</span>)
}</pre></div>
<p>这个接口声明了两个方法：<code>Get() string</code>,<code>Set(string)</code>，这两个方法合起来(<code>interface{ }</code>)就构成了一个接口，这个接口的名字叫做<code>GetSet</code>。</p>
<h2>
<a id="user-content-怎么实现一个interface" class="anchor" href="#%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAinterface" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>怎么实现一个interface</h2>
<h4>
<a id="user-content-说明" class="anchor" href="#%E8%AF%B4%E6%98%8E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>说明</h4>
<p>golang这门语言的接口与其他语言的不同之处在于，golang的接口是<code>隐式实现</code>的。</p>
<p>这是什么意思呢？</p>
<p>意思就是你不需要<code>显式</code>的这么做：</p>
<div class="highlight highlight-source-java"><pre><span class="pl-k">class</span> <span class="pl-en">SomeClass</span> <span class="pl-k">implements</span> <span class="pl-e">SomeInterface</span> {

}</pre></div>
<h4>
<a id="user-content-那怎么做" class="anchor" href="#%E9%82%A3%E6%80%8E%E4%B9%88%E5%81%9A" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>那怎么做？</h4>
<p>刚刚说了：「接口的实现是方法的实现的集合」，方法是定义在数据类型上面的，所以先给出一个数据类型：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">type</span> <span class="pl-v">Person</span> <span class="pl-k">struct</span> {
	<span class="pl-v">Name</span> <span class="pl-k">string</span>
	<span class="pl-v">Age</span>  <span class="pl-k">int</span>
}</pre></div>
<p>然后对这个数据类型实现接口定义里面所有声明的方法，也就是：<code>Get() string</code>,<code>Set(string)</code></p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">p</span> *<span class="pl-v">Person</span>) <span class="pl-en">Get</span></span>() <span class="pl-v">string</span> {
	<span class="pl-k">return</span> fmt.<span class="pl-c1">Sprintf</span>(<span class="pl-s"><span class="pl-pds">"</span>Person name: <span class="pl-c1">%6s</span>, age: <span class="pl-c1">%4d</span><span class="pl-pds">"</span></span>, p.<span class="pl-smi">Name</span>, p.<span class="pl-smi">Age</span>)
}

<span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">p</span> *<span class="pl-v">Person</span>) <span class="pl-en">Set</span></span>(<span class="pl-v">name</span> <span class="pl-v">string</span>) {
	p.<span class="pl-smi">Name</span> = name
}</pre></div>
<h4>
<a id="user-content-断言是否实现了接口" class="anchor" href="#%E6%96%AD%E8%A8%80%E6%98%AF%E5%90%A6%E5%AE%9E%E7%8E%B0%E4%BA%86%E6%8E%A5%E5%8F%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>断言是否实现了接口</h4>
<p>ok，到这里为止，我定义了一个接口<code>GetSet</code>，然后用<code>Person</code>实现了这个接口，一切都很美好，问题是，我真的实现了这个接口了吗？</p>
<p>有一个简单的方法去判断：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">var</span> <span class="pl-smi">_</span> <span class="pl-v">GetSet</span> = <span class="pl-c1">new</span>(Person) <span class="pl-c"><span class="pl-c">//</span> var _ GetSet = Person{}</span></pre></div>
<p>这是一个断言：<code>Person</code>的一个值实现了接口<code>GetSet</code>，如果<code>Person</code>没有实现了接口<code>GetSet</code>，编译的时候就会报错。</p>
<p>实际上，我们不需要创建一个变量（<code>new(Person)</code>），因为<code>Person</code>是任意值都实现了这个接口，所以<code>nil</code>也实现了，所以可以用类型转化做断言，代码如下：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">var</span> <span class="pl-smi">_</span> <span class="pl-v">GetSet</span> = (*Person)(<span class="pl-c1">nil</span>)</pre></div>
<h2>
<a id="user-content-空interface是什么" class="anchor" href="#%E7%A9%BAinterface%E6%98%AF%E4%BB%80%E4%B9%88" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>空interface是什么</h2>
<p>什么是空接口：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">interface</span>{}</pre></div>
<p>上面说过，接口是声明的方法的集合，空接口没有声明方法，所以任何类型都实现了空接口。</p>
<p>所以一个函数可以使用<code>interface{}</code>接受任意类型的值作为参数，也可以使用<code>interface{}</code>将任意类型的值作为返回值。</p>

    <div id="disqus_thread"></div>
    <script>

      /**
       *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
       *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
      /*
       var disqus_config = function () {
       this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
       this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
       };
       */
      (function () { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script')
        s.src = 'https://chyroc.disqus.com/embed.js'
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s)
      })()
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by
        Disqus.</a></noscript>
    <script id="dsq-count-scr" src="//chyroc.disqus.com/count.js" async></script>
</div>
</body>

</html>
