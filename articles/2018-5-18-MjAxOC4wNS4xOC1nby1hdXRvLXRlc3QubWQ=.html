
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>go中的自动测试 - Chyroc的博客</title>
<meta property="og:title" content="blog.chyroc.cn" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Chyroc的博客" />
<meta property="og:description" content="Chyroc的博客" />
<link rel="canonical" href="blog.chyroc.cn" />
<meta property="og:url" content="blog.chyroc.cn" />
<meta property="og:site_name" content="blog.chyroc.cn" />
<script type="application/ld+json">
{"name":"blog.chyroc.cn","description":"Chyroc的博客","author":"Chyroc","@type":"WebSite","url":"blog.chyroc.cn","image":null,"publisher":null,"headline":"blog.chyroc.cn","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>


<link href="https://blog.chyroc.cn/assets/css/style.css" rel="stylesheet">
</head>
<body>
<div class="container-lg px-3 my-5 markdown-body">

<h1>
<a id="user-content-go中的自动测试" class="anchor" href="#go%E4%B8%AD%E7%9A%84%E8%87%AA%E5%8A%A8%E6%B5%8B%E8%AF%95" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>go中的自动测试</h1>
<h2>
<a id="user-content-前言" class="anchor" href="#%E5%89%8D%E8%A8%80" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>前言</h2>
<p>最近在做leetcode的题目，需要搞一些简单的测试代码，但是测试函数的输入输出的描述、判断函数是否成功比较麻烦</p>
<p>所以我就在想，能不能我定义一个input和一个output，能够自动的将input转成go的代码，然后执行测试函数之后，比较返回值和output是否一致</p>
<p>要想这么做，肯定需要使用到反射，并且需要定义一下怎么从字符串转化到go的代码</p>
<h2>
<a id="user-content-parse字符串定义" class="anchor" href="#parse%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AE%9A%E4%B9%89" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>parse字符串定义</h2>
<ul>
<li>用逗号分隔数组的各个元素</li>
<li>用\n分隔多个输入或者多个输出</li>
<li>[1,2,3] 定义slice</li>
<li>{a: b} 定义map</li>
<li>slice或者map中的子元素的类型要看函数定义参数的类型</li>
</ul>
<h2>
<a id="user-content-代码解析" class="anchor" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>代码解析</h2>
<h3>
<a id="user-content-parseparam-这里需要自定义string转化" class="anchor" href="#parseparam-%E8%BF%99%E9%87%8C%E9%9C%80%E8%A6%81%E8%87%AA%E5%AE%9A%E4%B9%89string%E8%BD%AC%E5%8C%96" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>parseParam 这里需要自定义string转化</h3>
<p>参数是string / reflect.Type，返回值是reflect.Value</p>
<p>主要是tring to int,bool,slice,map，并转成reflect.Value的类型</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">parseParam</span>(<span class="pl-v">t</span> *<span class="pl-v">testing</span>.<span class="pl-v">T</span>, <span class="pl-v">param</span> <span class="pl-v">string</span>, <span class="pl-v">typ</span> <span class="pl-v">reflect</span>.<span class="pl-v">Type</span>) <span class="pl-v">reflect</span>.<span class="pl-v">Value</span> {
	<span class="pl-k">var</span> <span class="pl-smi">r</span> reflect.<span class="pl-smi">Value</span>
	<span class="pl-k">var</span> <span class="pl-smi">as</span> = assert.<span class="pl-c1">New</span>(t)
	param = strings.<span class="pl-c1">TrimSpace</span>(param)

	<span class="pl-k">switch</span> typ.<span class="pl-c1">Kind</span>() {
	<span class="pl-k">case</span> reflect.<span class="pl-smi">Int</span>:
		<span class="pl-smi">i</span>, <span class="pl-smi">err</span> <span class="pl-k">:=</span> strconv.<span class="pl-c1">Atoi</span>(param)
		as.<span class="pl-c1">Nil</span>(err)
		r = reflect.<span class="pl-c1">ValueOf</span>(i)
	<span class="pl-k">case</span> reflect.<span class="pl-smi">String</span>:
		r = reflect.<span class="pl-c1">ValueOf</span>(param)
	<span class="pl-k">case</span> reflect.<span class="pl-smi">Bool</span>:
		<span class="pl-smi">b</span>, <span class="pl-smi">err</span> <span class="pl-k">:=</span> strconv.<span class="pl-c1">ParseBool</span>(param)
		as.<span class="pl-c1">Nil</span>(err)
		r = reflect.<span class="pl-c1">ValueOf</span>(b)
	<span class="pl-k">case</span> reflect.<span class="pl-smi">Slice</span>:
		as.<span class="pl-c1">True</span>(<span class="pl-c1">len</span>(param) &gt; <span class="pl-c1">1</span>)
		as.<span class="pl-c1">True</span>(strings.<span class="pl-c1">HasPrefix</span>(param, <span class="pl-s"><span class="pl-pds">"</span>[<span class="pl-pds">"</span></span>))
		as.<span class="pl-c1">True</span>(strings.<span class="pl-c1">HasSuffix</span>(param, <span class="pl-s"><span class="pl-pds">"</span>]<span class="pl-pds">"</span></span>))
		param = strings.<span class="pl-c1">TrimPrefix</span>(param, <span class="pl-s"><span class="pl-pds">"</span>[<span class="pl-pds">"</span></span>)
		param = strings.<span class="pl-c1">TrimSuffix</span>(param, <span class="pl-s"><span class="pl-pds">"</span>]<span class="pl-pds">"</span></span>)
		<span class="pl-smi">s2</span> <span class="pl-k">:=</span> strings.<span class="pl-c1">Split</span>(param, <span class="pl-s"><span class="pl-pds">"</span>,<span class="pl-pds">"</span></span>)

		r = reflect.<span class="pl-c1">MakeSlice</span>(reflect.<span class="pl-c1">SliceOf</span>(typ.<span class="pl-c1">Elem</span>()), <span class="pl-c1">0</span>, <span class="pl-c1">0</span>)
		<span class="pl-k">for</span> <span class="pl-smi">_</span>, <span class="pl-smi">v</span> <span class="pl-k">:=</span> <span class="pl-k">range</span> s2 {
			r = reflect.<span class="pl-c1">Append</span>(r, <span class="pl-c1">parseParam</span>(t, v, typ.<span class="pl-c1">Elem</span>()))
		}
	<span class="pl-k">default</span>:
		<span class="pl-c1">panic</span>(fmt.<span class="pl-c1">Sprintf</span>(<span class="pl-s"><span class="pl-pds">"</span>not support <span class="pl-c1">%s</span><span class="pl-pds">"</span></span>, typ.<span class="pl-c1">Kind</span>()))
	}

	<span class="pl-k">return</span> r
}</pre></div>
<h3>
<a id="user-content-输入参数解析" class="anchor" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>输入参数解析</h3>
<div class="highlight highlight-source-go"><pre><span class="pl-smi">ft</span> <span class="pl-k">:=</span> reflect.<span class="pl-c1">TypeOf</span>(Func)
<span class="pl-smi">fv</span> <span class="pl-k">:=</span> reflect.<span class="pl-c1">ValueOf</span>(Func)</pre></div>
<p>然后遍历reflect.TypeOf(Func).In(i)，这个是输入参数的类型</p>
<p>将输入参数字符串转成对应类型的go代码：ithParamIn := parseParam(t, input[i], ithCallInType)</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">var</span> <span class="pl-smi">in</span> []reflect.<span class="pl-smi">Value</span>
<span class="pl-k">for</span> <span class="pl-smi">i</span> <span class="pl-k">:=</span> <span class="pl-c1">0</span>; i &lt; ft.<span class="pl-c1">NumIn</span>(); i++ {
	<span class="pl-smi">ithCallInType</span> <span class="pl-k">:=</span> ft.<span class="pl-c1">In</span>(i)

	<span class="pl-smi">ithParamIn</span> <span class="pl-k">:=</span> <span class="pl-c1">parseParam</span>(t, input[i], ithCallInType)

	in = <span class="pl-c1">append</span>(in, ithParamIn)
}</pre></div>
<h3>
<a id="user-content-执行测试函数" class="anchor" href="#%E6%89%A7%E8%A1%8C%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>执行测试函数</h3>
<div class="highlight highlight-source-go"><pre><span class="pl-smi">out</span> <span class="pl-k">:=</span> fv.<span class="pl-c1">Call</span>(in)</pre></div>
<p>这边的out是一个[]reflect.Value，需要将他和函数签名，以及给定的输出的字符串进行比较</p>
<h3>
<a id="user-content-输出参数解析和验证" class="anchor" href="#%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E5%92%8C%E9%AA%8C%E8%AF%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>输出参数解析和验证</h3>
<p>out 有三个，call返回，ft.Out(i)的，output的</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">for</span> <span class="pl-smi">i</span> <span class="pl-k">:=</span> <span class="pl-c1">0</span>; i &lt; ft.<span class="pl-c1">NumOut</span>(); i++ {
	<span class="pl-smi">ithCallRealOut</span> <span class="pl-k">:=</span> out[i] <span class="pl-c"><span class="pl-c">//</span> 比input多的</span>
	<span class="pl-smi">ithCallOutType</span> <span class="pl-k">:=</span> ft.<span class="pl-c1">Out</span>(i)
	<span class="pl-smi">ithCallOut</span> <span class="pl-k">:=</span> <span class="pl-c1">parseParam</span>(t, output[i], ithCallOutType)

	as.<span class="pl-c1">Equal</span>(ithCallOut.<span class="pl-c1">Kind</span>(), ithCallRealOut.<span class="pl-c1">Kind</span>())
	as.<span class="pl-c1">Equal</span>(ithCallOut.<span class="pl-c1">Kind</span>(), ithCallRealOut.<span class="pl-c1">Convert</span>(ithCallOutType).<span class="pl-c1">Kind</span>())
	as.<span class="pl-c1">Equal</span>(ithCallOut.<span class="pl-c1">Interface</span>(), ithCallRealOut.<span class="pl-c1">Convert</span>(ithCallOutType).<span class="pl-c1">Interface</span>())
}</pre></div>
<h2>
<a id="user-content-所以看看这怎么用" class="anchor" href="#%E6%89%80%E4%BB%A5%E7%9C%8B%E7%9C%8B%E8%BF%99%E6%80%8E%E4%B9%88%E7%94%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>所以看看这怎么用</h2>
<p>可以看到只要给了input和output的字符串，和要测试的函数，那么就能通过反射自动解析参数，执行测试代码，并看看是不是给定的输出</p>
<script src="https://gist.github.com/Chyroc/8dc21c2ea65dc3c83e43a62b3f2759e8.js"></script>
<h2>
<a id="user-content-代码地址" class="anchor" href="#%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>代码（<a href="https://github.com/Chyroc/algorithms-go/blob/master/test/run_case.go">地址</a>）</h2>
<script src="https://gist.github.com/Chyroc/3be97f3fc601a0a851e2bddbda48d89b.js"></script>


</div>

</body>
</html>
