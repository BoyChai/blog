
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>anko源代码阅读之整体结构（一） - Chyroc的博客</title>
<meta property="og:title" content="blog.chyroc.cn" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Chyroc的博客" />
<meta property="og:description" content="Chyroc的博客" />
<link rel="canonical" href="blog.chyroc.cn" />
<meta property="og:url" content="blog.chyroc.cn" />
<meta property="og:site_name" content="blog.chyroc.cn" />
<script type="application/ld+json">
{"name":"blog.chyroc.cn","description":"Chyroc的博客","author":"Chyroc","@type":"WebSite","url":"blog.chyroc.cn","image":null,"publisher":null,"headline":"blog.chyroc.cn","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>


<link href="https://blog.chyroc.cn/assets/css/style.css" rel="stylesheet">
</head>
<body>
<div class="container-lg px-3 my-5 markdown-body">

<h1>
<a id="user-content-anko源代码阅读之整体结构一" class="anchor" href="#anko%E6%BA%90%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E4%B9%8B%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E4%B8%80" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>anko源代码阅读之整体结构（一）</h1>
<blockquote>
<p>今天查资料的时候看见一句话：「我写博客的习惯，一直都在假想一个小白看我的文章，要怎么样才能说得让他看完我的博客就能明白我讲解的知识点。」，觉得对于我写文章具有指导性的意见，在这里记录下来。</p>
</blockquote>
<blockquote>
<p>这篇文章是在阅读<a href="https://github.com/mattn/anko">GitHub - mattn/anko: Scriptable interpreter written in golang</a>时候的笔记</p>
</blockquote>
<h2>
<a id="user-content-anko" class="anchor" href="#anko" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>anko</h2>
<p><a href="https://github.com/mattn/anko">GitHub - mattn/anko: Scriptable interpreter written in golang</a>是一个语法类似于go，并且使用go作为引擎执行的脚本语言。</p>
<p>公司目前使用的最常见的语言是go，在某些业务（如：提供用户在某些条件下触发trigger的能力）下，需要执行一些用户的脚本，这个时候，我们就用到了anko。</p>
<p>但是有几处地方使用到了anko，大家对于anko不断的重复封装，所以决定在公司内部封装一套含有我们内部API的anko。</p>
<p>我可能会涉及到这部分业务代码的编写和review，所以看了一下anko的源代码，这也是本篇文章的由来（如果有下一篇文章，那么也是本系列文章的由来。</p>
<p>注意：本代码阅读，截止commit：<a href="https://github.com/mattn/anko/commit/45d93882b6a0a4a02bd31a9265d325c44a8a4964">https://github.com/mattn/anko/commit/45d93882b6a0a4a02bd31a9265d325c44a8a4964</a> 。</p>
<h2>
<a id="user-content-我的疑问" class="anchor" href="#%E6%88%91%E7%9A%84%E7%96%91%E9%97%AE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>我的疑问</h2>
<ul>
<li>我以前没有接触过编译器相关，一直有一个疑问：如何识别代码</li>
<li>import如何处理</li>
<li>import的包和定义的函数怎么就调用到了</li>
</ul>
<h2>
<a id="user-content-代码结构" class="anchor" href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>代码结构</h2>
<p>anko代码里面有一些包，本节要讲的是：</p>
<pre><code>ast       // 抽象语法树结构
parser    // 解析脚本字符串，生成抽象语法树
vm        // 执行脚本
</code></pre>
<p>其他的暂时忽略掉</p>
<h2>
<a id="user-content-解析脚本生成抽象语法树" class="anchor" href="#%E8%A7%A3%E6%9E%90%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90%E6%8A%BD%E8%B1%A1%E8%AF%AD%E6%B3%95%E6%A0%91" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>解析脚本，生成抽象语法树</h2>
<p>代码参见：<a href="https://github.com/mattn/anko/blob/45d93882b6a0a4a02bd31a9265d325c44a8a4964/parser/lexer.go#L518">https://github.com/mattn/anko/blob/45d93882b6a0a4a02bd31a9265d325c44a8a4964/parser/lexer.go#L518</a></p>
<p>解析脚本的入口</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">import</span> <span class="pl-s"><span class="pl-pds">"</span>github.com/mattn/anko/ast<span class="pl-pds">"</span></span>

<span class="pl-k">func</span> <span class="pl-en">ParseSrc</span>(<span class="pl-v">src</span> <span class="pl-v">string</span>) ([]<span class="pl-v">ast</span>.<span class="pl-v">Stmt</span>, <span class="pl-v">error</span>)</pre></div>
<p>这里面的步骤如下：</p>
<ul>
<li>goyacc将parse包下的parsr.go.y文件生成为parse.go</li>
<li>lexer.go里面的<code>type Lexer struct</code>实现了生成的代码里面的<code>type yyLexer interface</code>
</li>
<li>
<code>Lexer</code>被传递给生成的代码里面的<code>yyParser</code>，进行解析</li>
<li>最后返回<code>l.stmts</code>作为解析结果，类型是<code>[]ast.Stmt</code>
</li>
</ul>
<p>到底如何解析，参见下一篇文章。</p>
<h2>
<a id="user-content-执行脚本" class="anchor" href="#%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>执行脚本</h2>
<p><a href="https://github.com/mattn/anko/blob/45d93882b6a0a4a02bd31a9265d325c44a8a4964/vm/vmStmt.go#L23">https://github.com/mattn/anko/blob/45d93882b6a0a4a02bd31a9265d325c44a8a4964/vm/vmStmt.go#L23</a></p>
<ul>
<li>循环<code>l.stmts</code>，执行代码</li>
</ul>
<p>执行代码的逻辑具体是什么，参见下一篇文章。</p>


</div>

</body>
</html>
