
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.3.0 -->
<title>chyroc.github.io | 基于issues的个人博客</title>
<meta property="og:title" content="chyroc.github.io" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="基于issues的个人博客" />
<meta property="og:description" content="基于issues的个人博客" />
<link rel="canonical" href="http://blog.chyroc.cn/articles/some.html" />
<meta property="og:url" content="http://blog.chyroc.cn/articles/some.html" />
<meta property="og:site_name" content="chyroc.github.io" />
<script type="application/ld+json">
{"name":null,"description":"基于issues的个人博客","author":null,"@type":"WebPage","url":"http://blog.chyroc.cn/articles/some.html","image":null,"publisher":null,"headline":"chyroc.github.io","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link href="/assets/css/style.css?v=efb62de7b7525b6b14733e28358121421ac29cfd" rel="stylesheet">
  </head>
  <body>
    <div class="container-lg px-3 my-5 markdown-body">

        <h1><a href="http://blog.chyroc.cn/">chyroc.github.io</a></h1>


      <p>目前做的一个业务涉及到<code class="highlighter-rouge">websocket</code>，在这里记录下来，虽然还不知道那个pr会不会过。</p>

<p>整个业务可以概括为：</p>
<blockquote>
  <p>涉及到三端：前端、后端和第三方服务商</p>
</blockquote>

<blockquote>
  <p>前端发起一个请求，会产生一个 <code class="highlighter-rouge">op_id</code></p>
</blockquote>

<blockquote>
  <p>第三方服务商在这个请求过程中，会不断<code class="highlighter-rouge">post</code>数据到后端提供的回调地址上</p>
</blockquote>

<blockquote>
  <p>后端需要把这些信息以<code class="highlighter-rouge">websocket</code>的方式提供给前端，以做好交互</p>
</blockquote>

<p>我大概想了一下，需要处理这么几个问题</p>

<ul>
  <li>用户验证（指<code class="highlighter-rouge">websocket</code>端的）</li>
  <li>绑定用户和<code class="highlighter-rouge">op_id</code>，使得<code class="highlighter-rouge">websocket</code>消息可以到达指定用户</li>
  <li>打开多个窗口，怎么保证收到的消息是一样的（同步）</li>
  <li>数据怎么从回调 <code class="highlighter-rouge">goroutine</code>传递到另外一个<code class="highlighter-rouge">websocket goroutine</code>内</li>
</ul>

<h3 id="用户验证">用户验证</h3>

<p><code class="highlighter-rouge">websocket</code>首先使用一个<code class="highlighter-rouge">get</code>请求建立连接，然后不再断开，可以在建立连接的时候进行身份认证</p>
<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"method"</span><span class="p">:</span><span class="w"> </span><span class="s2">"GET"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"path"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/websocket/:access_token"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"GET /websocket/........ HTTP/1.1......Connection: Upgrade.....Upgrade: websocket....."</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h3 id="数据绑定">数据绑定</h3>
<p>我使用的方法是在前端<code class="highlighter-rouge">前端发起一个请求，会产生一个 op_id</code>的时候，将<code class="highlighter-rouge">op_id</code>和<code class="highlighter-rouge">user_id</code>存在redis里面</p>

<p>没有存变量/channel 是因为需要保证在一个通话过程中，重启服务端不会清除数据</p>

<h3 id="多终端消息一致">多终端消息一致</h3>

<p>使用全局变量clients存储连接，对于同一user的多个终端，遍历存起来的链接，每个都进行消息发送。</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span><span class="x"> </span><span class="n">HandlerWebsocket</span><span class="p">(</span><span class="n">w</span><span class="x"> </span><span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span><span class="x"> </span><span class="n">r</span><span class="x"> </span><span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
  </span><span class="c">// ... some code</span><span class="x">

	</span><span class="n">clients</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">user</span><span class="p">,</span><span class="x"> </span><span class="n">c</span><span class="p">)</span><span class="x">
	</span><span class="k">defer</span><span class="x"> </span><span class="n">clients</span><span class="o">.</span><span class="n">Delete</span><span class="p">(</span><span class="n">userKey</span><span class="p">,</span><span class="x"> </span><span class="n">c</span><span class="p">)</span><span class="x">

	</span><span class="k">for</span><span class="x"> </span><span class="p">{</span><span class="x">
		</span><span class="k">if</span><span class="x"> </span><span class="n">v</span><span class="p">,</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">message</span><span class="p">[</span><span class="n">user</span><span class="p">];</span><span class="x"> </span><span class="n">ok</span><span class="x"> </span><span class="p">{</span><span class="x">
			</span><span class="n">message</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="o">&lt;-</span><span class="n">v</span><span class="x">

			</span><span class="n">cls</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="n">clients</span><span class="o">.</span><span class="n">Get</span><span class="p">(</span><span class="n">user</span><span class="p">)</span><span class="x">
			</span><span class="k">for</span><span class="x"> </span><span class="n">conn</span><span class="p">,</span><span class="x"> </span><span class="n">_</span><span class="x"> </span><span class="o">:=</span><span class="x"> </span><span class="k">range</span><span class="x"> </span><span class="n">cls</span><span class="x"> </span><span class="p">{</span><span class="x"> </span><span class="c">// 这里有循环对同一用户进行消息广播</span><span class="x">
				</span><span class="n">conn</span><span class="o">.</span><span class="n">WriteJSON</span><span class="p">(</span><span class="n">message</span><span class="p">)</span><span class="x">
			</span><span class="p">}</span><span class="x">
		</span><span class="p">}</span><span class="x">
	</span><span class="p">}</span><span class="x">
</span><span class="p">}</span><span class="x">
</span></code></pre></div></div>

<p>这是存储用户和链接的数据结构（简化版）。</p>

<p>这里有一个问题，指针可以作为key，而<code class="highlighter-rouge">websocket.Conn</code>不行，原因忘了，原来有一次看到过。</p>
<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">map</span><span class="p">[</span><span class="o">*</span><span class="n">websocket</span><span class="o">.</span><span class="n">Conn</span><span class="p">]</span><span class="kt">bool</span><span class="x">
</span></code></pre></div></div>

<h3 id="goroutine间数据传递">goroutine间数据传递</h3>

<p>使用channel</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span><span class="x"> </span><span class="n">message</span><span class="x"> </span><span class="o">=</span><span class="x"> </span><span class="nb">make</span><span class="p">(</span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">](</span><span class="k">chan</span><span class="x"> </span><span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">interface</span><span class="p">{}))</span><span class="x">

</span><span class="k">func</span><span class="x"> </span><span class="n">HandlerCallback</span><span class="p">(</span><span class="n">body</span><span class="x"> </span><span class="n">CallbackBody</span><span class="p">)</span><span class="x"> </span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="x"> </span><span class="kt">string</span><span class="p">)</span><span class="x"> </span><span class="p">{</span><span class="x">
	</span><span class="c">// ... some code</span><span class="x">

	</span><span class="n">message</span><span class="p">[</span><span class="n">user</span><span class="p">]</span><span class="x"> </span><span class="o">&lt;-</span><span class="x"> </span><span class="n">body</span><span class="x">

	</span><span class="c">// ... some code</span><span class="x">
</span><span class="p">}</span><span class="x">

</span><span class="c">// 使用见前一小节</span><span class="x">
</span></code></pre></div></div>



    </div>
    <script src="/assets/javascript/anchor-js/anchor.min.js"></script>
    <script>anchors.add();</script>



    <div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://chyroc.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



<script id="dsq-count-scr" src="//chyroc.disqus.com/count.js" async></script>




  </body>
</html>
