
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>tiedot阅读笔记（一）	 - Chyroc的博客</title>
<meta property="og:title" content="blog.chyroc.cn" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Chyroc的博客" />
<meta property="og:description" content="Chyroc的博客" />
<link rel="canonical" href="blog.chyroc.cn" />
<meta property="og:url" content="blog.chyroc.cn" />
<meta property="og:site_name" content="blog.chyroc.cn" />
<script type="application/ld+json">
{"name":"blog.chyroc.cn","description":"Chyroc的博客","author":"Chyroc","@type":"WebSite","url":"blog.chyroc.cn","image":null,"publisher":null,"headline":"blog.chyroc.cn","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>


<link href="http://blog.chyroc.cn/assets/css/style.css" rel="stylesheet">
</head>
<body>
<div class="container-lg px-3 my-5 markdown-body">

<h1>
<a id="user-content-tiedot阅读笔记一" class="anchor" href="#tiedot%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B8%80" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>tiedot阅读笔记（一）</h1>
<p>#tiedot
Tiedot是一个完全使用go实现的文档型的NoSQL，项目地址是：<a href="https://github.com/HouzuoGuo/tiedot">GitHub - HouzuoGuo/tiedot: Your NoSQL database powered by Golang</a></p>
<h2>
<a id="user-content-项目结构" class="anchor" href="#%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>项目结构</h2>
<p>使用命令<code>tree -L 1</code>查看目录结构：</p>
<div class="highlight highlight-source-shell"><pre><span class="pl-c1">.</span>
├── Dockerfile
├── LICENSE
├── README.md
├── benchmark
├── data
├── db
├── dberr
├── distributable
├── doc
├── docker-compose.yml
├── examples
├── extra
├── gommap
├── httpapi
├── main.go
├── tdlog
├── test-and-coverage-report.sh
└── vendor</pre></div>
<h2>
<a id="user-content-如何存储数据" class="anchor" href="#%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>如何存储数据</h2>
<h3>
<a id="user-content-文件结构与条件编译" class="anchor" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E4%B8%8E%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>文件结构与条件编译</h3>
<p>存储数据的代码全部在data里面，这篇文章先只关注这个
<code>tree data | grep -v '_test.go'</code>
数据：</p>
<div class="highlight highlight-source-shell"><pre>data
├── collection.go
├── collection32.go
├── collection64.go
├── config.go
├── file.go
├── hash32.go
├── hash64.go
├── hashtable.go
├── partition.go</pre></div>
<p>其中<code>*32.go</code>和<code>*64.go</code>是针对不同的os进行兼容的代码，可以通过文件头部指定编译条件：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-c"><span class="pl-c">//</span> *32.go</span>
<span class="pl-c"><span class="pl-c">//</span> +build 386 arm</span>

<span class="pl-c"><span class="pl-c">//</span> *64.go</span>
<span class="pl-c"><span class="pl-c">//</span> +build !386,!arm</span></pre></div>
<h2>
<a id="user-content-如何存储字节数据下面两个数据的基础" class="anchor" href="#%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E4%B8%8B%E9%9D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E7%A1%80" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>如何存储字节数据（下面两个数据的基础）</h2>
<p>代码：<a href="https://github.com/HouzuoGuo/tiedot/blob/master/data/file.go">tiedot/file.go at master · HouzuoGuo/tiedot · GitHub</a>
这部分代码借鉴了：<a href="https://github.com/edsrzf/mmap-go">GitHub - edsrzf/mmap-go: A portable mmap package for Go</a>，主要的作用就是将数据从文件读入内存。
其中定义了一个数据结构：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">type</span> <span class="pl-v">DataFile</span> <span class="pl-k">struct</span> {
	<span class="pl-v">Path</span>   <span class="pl-k">string</span> <span class="pl-c"><span class="pl-c">//</span> 文件路径，没什么好解释的</span>
	<span class="pl-v">Used</span>   <span class="pl-k">int</span> <span class="pl-c"><span class="pl-c">//</span> 已经使用的大小，单位字节。但是这个还有一个作用，下面会介绍</span>
	<span class="pl-v">Size</span>   <span class="pl-k">int</span> <span class="pl-c"><span class="pl-c">//</span> 文件大小</span>
	<span class="pl-v">Growth</span> <span class="pl-k">int</span> <span class="pl-c"><span class="pl-c">//</span> 当使用的数据大小超过了文件的大小的时候，就需要增加文件的大小。这个数据就是一次所增加的大小</span>
	<span class="pl-v">Fh</span>     *os.<span class="pl-smi">File</span> <span class="pl-c"><span class="pl-c">//</span> 文件指针，没什么好解释的</span>
	<span class="pl-v">Buf</span> gommap.<span class="pl-smi">MMap</span> <span class="pl-c"><span class="pl-c">//</span> 重点，内存数据，字节数组！下面操作数据，都是通过操作这个字段来实现的。</span>
}</pre></div>
<h3>
<a id="user-content-从buf中读取数据" class="anchor" href="#%E4%BB%8Ebuf%E4%B8%AD%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>从<code>Buf</code>中读取数据</h3>
<p>如果数据是数字的话：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-smi">room</span>, <span class="pl-smi">_</span> <span class="pl-k">:=</span> binary.<span class="pl-c1">Varint</span>(col.<span class="pl-smi">Buf</span>[id+<span class="pl-c1">1</span>: id+<span class="pl-c1">11</span>])</pre></div>
<p>如果就是字节的话：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-smi">docCopy</span> <span class="pl-k">:=</span> <span class="pl-c1">make</span>([]<span class="pl-k">byte</span>, length)
<span class="pl-c1">copy</span>(docCopy, col.<span class="pl-smi">Buf</span>[x:y])</pre></div>
<h3>
<a id="user-content-写入数据到buf" class="anchor" href="#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%88%B0buf" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>写入数据到<code>Buf</code>
</h3>
<p>如果数据是数字的话：</p>
<div class="highlight highlight-source-go"><pre>binary.<span class="pl-c1">PutVarint</span>(Buf[x:y], int64Data)</pre></div>
<p>如果就是字节的话：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-c1">copy</span>(Buf[x:y], data)</pre></div>
<h2>
<a id="user-content-如何存储doc文档" class="anchor" href="#%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8doc%E6%96%87%E6%A1%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>如何存储doc(文档)</h2>
<p>在tiedot里面定义了一个叫做<code>Collection</code>的东西，这个将作为doc的数据载体，<code>Collection</code>内嵌了<code>DataFile</code>数据接口。
它实现了这么几个方法，前四个是增删查改，第五个是一个map函数。
<a href="tie2/0005C20E-CAD8-4196-815D-40BC5FDDC460.png" target="_blank"><img src="tie2/0005C20E-CAD8-4196-815D-40BC5FDDC460.png" alt="" style="max-width:100%;"></a></p>
<h3>
<a id="user-content-insert-doc" class="anchor" href="#insert-doc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>insert doc</h3>
<p>函数签名</p>
<div class="highlight highlight-source-go"><pre><span class="pl-c1">Insert</span>(data []<span class="pl-k">byte</span>) (id <span class="pl-k">int</span>, err <span class="pl-k">error</span>)</pre></div>
<p><code>Collection</code>中的<code>Buf</code>数据以<code>doc</code>组成，<code>doc</code>是不连续的，每一个<code>doc</code>的数据结构是：</p>
<pre><code>+------------------------------------+
| flag | doc length |    doc data    |
0------1-----------11-----...------end
</code></pre>
<ul>
<li>第1个字节存储当前字节开始是否是一个doc</li>
<li>第2个到11个字节（共10个）存储本doc的长度，假设为<code>len</code>
</li>
<li>然后第12个到<code>11+len</code>个字节存储的是doc的数据
问题</li>
<li>返回的id如何确定
Id就是这个doc的其实的字节序号，使用<code>Used</code>来确定。
所以在insert完数据之后，需要将本doc的大小加入到里面：</li>
</ul>
<div class="highlight highlight-source-go"><pre>col.<span class="pl-smi">Used</span> += docSize</pre></div>
<ul>
<li>分配的大小如何确定
参数大小的两倍，剩余的部分，使用空白填充。
好处是更新的时候，如果新的doc的大小不超过旧的两倍，那么就不需要重新分配地址和id</li>
</ul>
<h3>
<a id="user-content-update-doc" class="anchor" href="#update-doc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>update doc</h3>
<p>函数签名</p>
<div class="highlight highlight-source-go"><pre><span class="pl-c1">Update</span>(id <span class="pl-k">int</span>, data []<span class="pl-k">byte</span>) (newID <span class="pl-k">int</span>, err <span class="pl-k">error</span>)</pre></div>
<p>分两种情况</p>
<ul>
<li>新doc大小小于原来分配的大小
直接更新元老的数据就行</li>
<li>新doc大小大于原来分配的大小
先删除，再插入</li>
</ul>
<h3>
<a id="user-content-delete-doc" class="anchor" href="#delete-doc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>delete doc</h3>
<p>函数签名</p>
<div class="highlight highlight-source-go"><pre><span class="pl-c1">Delete</span>(id <span class="pl-k">int</span>) <span class="pl-k">error</span></pre></div>
<p>将标志位置为<code>0</code>就行了</p>
<h3>
<a id="user-content-read-doc" class="anchor" href="#read-doc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>read doc</h3>
<div class="highlight highlight-source-go"><pre><span class="pl-c1">Read</span>(id <span class="pl-k">int</span>) []<span class="pl-k">byte</span></pre></div>
<p>先读出来doc length这个数据（2-11字节）
然后用这个数据长度去读buf的数据（第12个到<code>11+len</code>个字节）</p>
<h2>
<a id="user-content-如何存储index索引哈希表" class="anchor" href="#%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8index%E7%B4%A2%E5%BC%95%E5%93%88%E5%B8%8C%E8%A1%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>如何存储index(索引，哈希表)</h2>
<h3>
<a id="user-content-总览" class="anchor" href="#%E6%80%BB%E8%A7%88" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>总览</h3>
<p>使用了bucket和entry实现了一个哈希表，每一个bucket拥有固定数量的entry，每一个entry存储了一对键值对。
当一个bucket满了的时候，会有一个新的bucket链接到这个bucket后面，形成一个bucket链。
因为是索引，所以没有修改接口，只有增删查。
<a href="tie2/7DABA9B8-AAF4-41F4-957B-AAABDE87167E.png" target="_blank"><img src="tie2/7DABA9B8-AAF4-41F4-957B-AAABDE87167E.png" alt="" style="max-width:100%;"></a></p>
<h3>
<a id="user-content-bucket" class="anchor" href="#bucket" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>bucket</h3>
<p>结构是</p>
<pre><code>+----------------------------------------------------+
| next bucket addr | entry1 | entry2 | ... | entry16 |
0 ---------------- 10------31-------52-------------346
</code></pre>
<h3>
<a id="user-content-entry" class="anchor" href="#entry" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>entry</h3>
<p>结构是，共21字节</p>
<pre><code>+--------------------+
| flag | key | value |
0------1----11------21
</code></pre>
<ul>
<li>第1字节：是否是一个entry</li>
<li>2-11字节：key值，一个int</li>
<li>12-21字节：value值，一个int</li>
</ul>
<p>因为一个bucket会有若干个entry，所以知道了bucket的地址，那么就可以计算出所有的entry的地址：</p>
<div class="highlight highlight-source-go"><pre><span class="pl-smi">entryAddr</span> <span class="pl-k">:=</span> bucket*ht.<span class="pl-smi">BucketSize</span> + <span class="pl-v">BucketHeader</span> + entry*EntrySize
<span class="pl-c"><span class="pl-c">//</span> ht.BucketSize = BucketHeader + conf.PerBucket*EntrySize = 10 + 16 * 21 = 346 字节</span>
<span class="pl-c"><span class="pl-c">//</span> BucketHeader 记录了下一个bucket的地址，10 字节</span>
<span class="pl-c"><span class="pl-c">//</span> entry 第几个entry，从0开始</span>
<span class="pl-c"><span class="pl-c">//</span> EntrySize entry大小，21字节</span></pre></div>
<ul>
<li>1-10：指向下一个bucket的地址</li>
<li>11-31：21个字节，是一个entry</li>
<li>…：每21个字节是一个entry，连续的</li>
</ul>
<h3>
<a id="user-content-哈希函数hashkey" class="anchor" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0hashkey" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>哈希函数HashKey</h3>
<p>函数签名</p>
<div class="highlight highlight-source-go"><pre><span class="pl-c1">HashKey</span>(key <span class="pl-k">int</span>) <span class="pl-k">int</span></pre></div>
<p>返回值是一个<code>0-65535</code>之间的整数（这个也是bucket初始化的时候的范围）</p>
<h3>
<a id="user-content-增" class="anchor" href="#%E5%A2%9E" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>增</h3>
<p>函数签名</p>
<div class="highlight highlight-source-go"><pre><span class="pl-c1">Put</span>(key, val <span class="pl-k">int</span>)</pre></div>
<ul>
<li>使用<code>HashKey</code>计算key的哈希作为bucket（序号）</li>
<li>循环这个bucket的所有entry，看看是不是还有空的（通过标志位判断），有就写入数据，entry循环是<code>entry++</code>
</li>
<li>如果entry到达了16，也就是一个bucket所能容纳的entry的极限，就会找到下一个bucket，继续循环，这里使用了<code>nextBucket(bucket int) int</code>，从前10个字节取下一个bucket的地址</li>
<li>如果是最后一个bucket，那么就需要新添加一个，使用函数<code>growBucket(bucket int)</code>
</li>
</ul>
<h3>
<a id="user-content-删" class="anchor" href="#%E5%88%A0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>删</h3>
<p>通过哈希表找到那个数据，然后将标志位置为0</p>
<h3>
<a id="user-content-查" class="anchor" href="#%E6%9F%A5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>查</h3>
<p>一样的</p>
<h2>
<a id="user-content-doc与index的结合" class="anchor" href="#doc%E4%B8%8Eindex%E7%9A%84%E7%BB%93%E5%90%88" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>doc与index的结合</h2>
<p>数据结构</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">type</span> <span class="pl-v">Partition</span> <span class="pl-k">struct</span> {
	<span class="pl-c"><span class="pl-c">//</span> 是这个par对应的doc存储地方</span>
	col *Collection

	<span class="pl-c"><span class="pl-c">//</span> 哈希表</span>
	lookup *HashTable

	<span class="pl-c"><span class="pl-c">//</span> 访问 doc 加锁</span>
	<span class="pl-v">DataLock</span> *sync.<span class="pl-smi">RWMutex</span> <span class="pl-c"><span class="pl-c">//</span> guard against concurrent document updates</span>
}</pre></div>
<p>方法
<a href="tie2/EB46196A-441E-4DEA-AC84-6E8C4C1F49CE.png" target="_blank"><img src="tie2/EB46196A-441E-4DEA-AC84-6E8C4C1F49CE.png" alt="" style="max-width:100%;"></a></p>
<h3>
<a id="user-content-增-1" class="anchor" href="#%E5%A2%9E-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>增</h3>
<p>函数签名</p>
<pre><code>Insert(id int, data []byte) (physID int, err error)
</code></pre>
<p>第一个参数id是一个随机数，在生成之后是不变的（也就是更新doc仍然不变）</p>
<ul>
<li>先将数据插入col，返回一个真实数据的id</li>
<li>然后把doc id 和真实id存在哈希表</li>
</ul>
<h3>
<a id="user-content-删-1" class="anchor" href="#%E5%88%A0-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>删</h3>
<p>函数签名</p>
<pre><code>Delete(id int) (err error)
</code></pre>
<ul>
<li>通过哈希表找到对应的真实id</li>
<li>删除真实id所在的数据</li>
<li>删除真实id和doc id对应的哈希表数据</li>
</ul>
<h3>
<a id="user-content-查-1" class="anchor" href="#%E6%9F%A5-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>查</h3>
<p>函数签名</p>
<pre><code>Read(id int) ([]byte, error)
</code></pre>
<ul>
<li>通过doc id找到真实id</li>
<li>然后通过它查询数据</li>
</ul>
<h3>
<a id="user-content-改" class="anchor" href="#%E6%94%B9" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>改</h3>
<p>函数签名</p>
<pre><code>Update(id int, data []byte) (err error) 
</code></pre>
<ul>
<li>找到真实id</li>
<li>更新数据</li>
<li>如果返回的真实id和获取的不一致，需要将doc id与真实id的对应关系更新一下</li>
</ul>


</div>

</body>
</html>
