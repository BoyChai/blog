
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Golang中的context - Chyroc的博客</title>
<meta property="og:title" content="blog.chyroc.cn" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Chyroc的博客" />
<meta property="og:description" content="Chyroc的博客" />
<link rel="canonical" href="blog.chyroc.cn" />
<meta property="og:url" content="blog.chyroc.cn" />
<meta property="og:site_name" content="blog.chyroc.cn" />
<script type="application/ld+json">
{"name":"blog.chyroc.cn","description":"Chyroc的博客","author":"Chyroc","@type":"WebSite","url":"blog.chyroc.cn","image":null,"publisher":null,"headline":"blog.chyroc.cn","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}</script>


<link href="https://blog.chyroc.cn/assets/css/style.css" rel="stylesheet">
</head>
<body>
<div class="container-lg px-3 my-5 markdown-body">

<h1>
<a id="user-content-golang中的context" class="anchor" href="#golang%E4%B8%AD%E7%9A%84context" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Golang中的context</h1>
<blockquote>
<p>前几天在工作中使用context的时候，对于metadata和context.Value有一些疑惑，顺便探索了一下go的context，在这里分享一下</p>
</blockquote>
<blockquote>
<p>现在是2018-04-29 19:49，正在北京开往家的动车上，窗外已经是黑黑的一片了，11点到家，写一会文章吧</p>
</blockquote>
<h2>
<a id="user-content-context包" class="anchor" href="#context%E5%8C%85" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>context包</h2>
<p>这里说的context包指的是golang(1.8+)中的标准库context，文档在这里：<a href="https://godoc.org/context" rel="nofollow">https://godoc.org/context</a> 。</p>
<p>context包定义了Context类型，他可以在携带deadlines和cancelatin信号，也可以携带其他的请求值。</p>
<p>发送到server的请求应该创建一个context，服务器处理请求的时候也应该接受一个context。在程序的函数调用链中，必须传递context，也可以基于一个context，使用WithCancel, WithDeadline, WithTimeout, or WithValue等函数创建一个新的context传递下去。当一个context被canceled的时候，那么所有通过改context派生的context都应该被cancel</p>
<p>WithCancel, WithDeadline, and WithTimeout这三个函数使用一个context(the parent) 作为参数，然后创建一个新的context（the child）和CancelFunc函数。调用CancelFunc函数将会取消该child和他的children，移除parent到child的应用，然后停止任何相关的timeers。吐过调用这个函数失败的话，会导致child和他的children知道parent cancel的时候或者timer fired的时候才会取消。go vet工具会检查CancelFuncs对否在所有的控制分支上使用了。</p>
<p>context的使用规则</p>
<ul>
<li>context应该作为函数参数传递，而不是struct的一个field</li>
<li>context应该是函数的第一个参数</li>
<li>不要传递nil context，即使是不使用，如果不知道用啥，用 context.TODO 吧</li>
<li>只使用context传递请求上下文，而不是为了传递可选参数</li>
<li>context可能会被同一个函数在不同的goroutine中使用，他是并发安全的</li>
</ul>
<h2>
<a id="user-content-context接口" class="anchor" href="#context%E6%8E%A5%E5%8F%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>context接口</h2>
<p>以下是context的接口定义</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">type</span> <span class="pl-v">Context</span> <span class="pl-k">interface</span> {
    <span class="pl-c"><span class="pl-c">//</span> 返回当前context应该被cancel的时间</span>
    <span class="pl-c"><span class="pl-c">//</span> 如果 ok==false 的话，那么当前context没有deadline</span>
    <span class="pl-c1">Deadline</span>() (deadline time.<span class="pl-smi">Time</span>, ok <span class="pl-k">bool</span>)

    <span class="pl-c"><span class="pl-c">//</span> 返回了一个chan，当 当前context被cancel的时候，这个chan就会被close</span>
    <span class="pl-c"><span class="pl-c">//</span> 如果这个context永远也不会被cancel的时候，会返回一个nil</span>
    <span class="pl-c"><span class="pl-c">//</span></span>
    <span class="pl-c"><span class="pl-c">//</span> WithCancel会在cancel的遍历Done</span>
    <span class="pl-c"><span class="pl-c">//</span> WithDeadline</span>
    <span class="pl-c"><span class="pl-c">//</span> WithTimeout</span>
    <span class="pl-c"><span class="pl-c">//</span></span>
    <span class="pl-c"><span class="pl-c">//</span> Done是为了在select中使用提供的</span>
    <span class="pl-c"><span class="pl-c">//</span></span>
    <span class="pl-c"><span class="pl-c">//</span>  // Stream generates values with DoSomething and sends them to out</span>
    <span class="pl-c"><span class="pl-c">//</span>  // until DoSomething returns an error or ctx.Done is closed.</span>
    <span class="pl-c"><span class="pl-c">//</span>  func Stream(ctx context.Context, out chan&lt;- Value) error {</span>
    <span class="pl-c"><span class="pl-c">//</span>  	for {</span>
    <span class="pl-c"><span class="pl-c">//</span>  		v, err := DoSomething(ctx)</span>
    <span class="pl-c"><span class="pl-c">//</span>  		if err != nil {</span>
    <span class="pl-c"><span class="pl-c">//</span>  			return err</span>
    <span class="pl-c"><span class="pl-c">//</span>  		}</span>
    <span class="pl-c"><span class="pl-c">//</span>  		select {</span>
    <span class="pl-c"><span class="pl-c">//</span>  		case &lt;-ctx.Done():</span>
    <span class="pl-c"><span class="pl-c">//</span>  			return ctx.Err()</span>
    <span class="pl-c"><span class="pl-c">//</span>  		case out &lt;- v:</span>
    <span class="pl-c"><span class="pl-c">//</span>  		}</span>
    <span class="pl-c"><span class="pl-c">//</span>  	}</span>
    <span class="pl-c"><span class="pl-c">//</span>  }</span>
    <span class="pl-c"><span class="pl-c">//</span></span>
    <span class="pl-c"><span class="pl-c">//</span> See https://blog.golang.org/pipelines for more examples of how to use</span>
    <span class="pl-c"><span class="pl-c">//</span> a Done channel for cancelation.</span>
    <span class="pl-c1">Done</span>() <span class="pl-k">&lt;-</span><span class="pl-k">chan</span> <span class="pl-k">struct</span>{}

    <span class="pl-c"><span class="pl-c">//</span> 如果Done还没有被close，返回nil</span>
    <span class="pl-c"><span class="pl-c">//</span> 如果Done已经被clode了，返回一个non-nil的err，有几个err：</span>
    <span class="pl-c"><span class="pl-c">//</span> Canceled： context是被cancel的</span>
    <span class="pl-c"><span class="pl-c">//</span> DeadlineExceeded： context的deadline过了</span>
    <span class="pl-c"><span class="pl-c">//</span> 如果Err返回了一个non-nil，那么以后返回的结果也都是一样的</span>
    <span class="pl-c1">Err</span>() <span class="pl-k">error</span>

    <span class="pl-c"><span class="pl-c">//</span> 返回指定的key的值，如果没有，返回nil</span>
    <span class="pl-c"><span class="pl-c">//</span></span>
    <span class="pl-c"><span class="pl-c">//</span> 一个key指定了context中唯一的value。</span>
    <span class="pl-c"><span class="pl-c">//</span> key可以是任何可以比较的类型，(golint不允许使用string)</span>
    <span class="pl-c"><span class="pl-c">//</span> 各个包应该定义自己的非导出的类型所谓key，以避免重叠</span>
    <span class="pl-c1">Value</span>(key <span class="pl-k">interface</span>{}) <span class="pl-k">interface</span>{}
}</pre></div>
<h2>
<a id="user-content-context是如何实现k-v键值对存储的" class="anchor" href="#context%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0k-v%E9%94%AE%E5%80%BC%E5%AF%B9%E5%AD%98%E5%82%A8%E7%9A%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>context是如何实现k-v键值对存储的</h2>
<h3>
<a id="user-content-什么是contextk-v存储" class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AFcontextk-v%E5%AD%98%E5%82%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>什么是contextk-v存储</h3>
<p>通过下面这样的代码可以在goroutine之间安全的传递数据</p>
<div class="highlight highlight-source-go"><pre>	<span class="pl-k">type</span> key = <span class="pl-k">struct</span>{}
	<span class="pl-smi">ctx</span> <span class="pl-k">:=</span> context.<span class="pl-c1">Background</span>()

	ctx = context.<span class="pl-c1">WithValue</span>(ctx, key{}, <span class="pl-s"><span class="pl-pds">"</span>this is value<span class="pl-pds">"</span></span>)

	fmt.<span class="pl-c1">Printf</span>(<span class="pl-s"><span class="pl-pds">"</span>value: <span class="pl-c1">%v</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, ctx.<span class="pl-c1">Value</span>(key{}))</pre></div>
<h3>
<a id="user-content-简析" class="anchor" href="#%E7%AE%80%E6%9E%90" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>简析</h3>
<p>context值的实现和cancel等的实现是基于不同的struct的，这些struct都和接口Context组合了，所以都<code>实现</code>了接口Context（参见<a href="http://blog.chyroc.cn/articles/2017-8-3-247632972.html%EF%BC%89" rel="nofollow">http://blog.chyroc.cn/articles/2017-8-3-247632972.html）</a></p>
<p>这种思想是可以借鉴的，即先定义一个interface，然后不同的struct组合这个interface，然后实现不同的方法</p>
<p>context的k-v对存储是一个树状的结构，每个节点都存储一对k-v，并指向父context</p>
<h3>
<a id="user-content-代码解析" class="anchor" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>代码解析</h3>
<p>下面结合k-v实现的代码看一下</p>
<div class="highlight highlight-source-go"><pre><span class="pl-c"><span class="pl-c">//</span> 定义存储k-v的struct，是一个树结构</span>
<span class="pl-k">type</span> valueCtx <span class="pl-k">struct</span> {
	<span class="pl-v">Context</span>
	key, val <span class="pl-k">interface</span>{}
}

<span class="pl-c"><span class="pl-c">//</span> String接口</span>
<span class="pl-c"><span class="pl-c">//</span> 其中的c.Context是通过`%v`格式化的，所以这个函数实际上是一个递归函数</span>
<span class="pl-c"><span class="pl-c">//</span> 这里使用%v作为递归的方法而不是c.Context.String()，是因为Context接口没有定义String方法，而valueCtx没有定义，这一点值得学习</span>
<span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">c</span> *<span class="pl-v">valueCtx</span>) <span class="pl-en">String</span></span>() <span class="pl-v">string</span> {
	<span class="pl-k">return</span> fmt.<span class="pl-c1">Sprintf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%v</span>.WithValue(<span class="pl-c1">%#v</span>, <span class="pl-c1">%#v</span>)<span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, c.<span class="pl-smi">Context</span>, c.<span class="pl-smi">key</span>, c.<span class="pl-smi">val</span>)
}

<span class="pl-c"><span class="pl-c">//</span> 取值方法</span>
<span class="pl-c"><span class="pl-c">//</span> 先判断当前context中是否有该存储的值</span>
<span class="pl-c"><span class="pl-c">//</span> 没有就使用父context取，也是一个递归函数</span>
<span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">c</span> *<span class="pl-v">valueCtx</span>) <span class="pl-en">Value</span></span>(<span class="pl-v">key</span> <span class="pl-v">interface</span>{}) <span class="pl-v">interface</span>{} {
	<span class="pl-k">if</span> c.<span class="pl-smi">key</span> == key {
		<span class="pl-k">return</span> c.<span class="pl-smi">val</span>
	}
	<span class="pl-k">return</span> c.<span class="pl-smi">Context</span>.<span class="pl-c1">Value</span>(key)
}

<span class="pl-c"><span class="pl-c">//</span> 赋值方法</span>
<span class="pl-c"><span class="pl-c">//</span> 实际上是返回一个struct，这个struct里面有key和val的field，作为k-v的存储载体</span>
<span class="pl-c"><span class="pl-c">//</span> 然后为了保留意见设置的数据，需要把老context传下去</span>
<span class="pl-c"><span class="pl-c">//</span> 所以大概是这么个格式：{{{context.TODO(), key1, val1}, key2, val2}, key3, val3}</span>
<span class="pl-c"><span class="pl-c">//</span> 所以如果在同一个key上设置了两个值，那么旧的值永远不会取出来，因为会先取到后设置的值；所以也可以直接理解为一个map（实际上复杂度不是O(1)的）</span>
<span class="pl-k">func</span> <span class="pl-en">WithValue</span>(<span class="pl-v">parent</span> <span class="pl-v">Context</span>, <span class="pl-v">key</span>, <span class="pl-v">val</span> <span class="pl-v">interface</span>{}) <span class="pl-v">Context</span> {
	<span class="pl-k">if</span> key == <span class="pl-c1">nil</span> {
		<span class="pl-c1">panic</span>(<span class="pl-s"><span class="pl-pds">"</span>nil key<span class="pl-pds">"</span></span>)
	}
	<span class="pl-k">if</span> !reflect.<span class="pl-c1">TypeOf</span>(key).<span class="pl-c1">Comparable</span>() {
		<span class="pl-c1">panic</span>(<span class="pl-s"><span class="pl-pds">"</span>key is not comparable<span class="pl-pds">"</span></span>)
	}
	<span class="pl-k">return</span> &amp;valueCtx{parent, key, val}
}</pre></div>
<h2>
<a id="user-content-怎么使用context控制goroutine的cancel的" class="anchor" href="#%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8context%E6%8E%A7%E5%88%B6goroutine%E7%9A%84cancel%E7%9A%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>怎么使用context控制goroutine的cancel的</h2>
<h3>
<a id="user-content-如何使用" class="anchor" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>如何使用</h3>
<p>这里的gen函数创建了一个goroutine，返回一个递增的生成器；</p>
<p>主函数range这个生成器（其实是chan），执行5次后退出主函数</p>
<p>这个时候触发defer执行cancel函数，执行ctx.Done</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">package</span> main

<span class="pl-k">import</span> (
    <span class="pl-s"><span class="pl-pds">"</span>context<span class="pl-pds">"</span></span>
    <span class="pl-s"><span class="pl-pds">"</span>fmt<span class="pl-pds">"</span></span>
)

<span class="pl-k">func</span> <span class="pl-en">gen</span>(<span class="pl-v">ctx</span> <span class="pl-v">context</span>.<span class="pl-v">Context</span>) &lt;-<span class="pl-v">chan</span> <span class="pl-v">int</span> {
    <span class="pl-smi">dst</span> <span class="pl-k">:=</span> <span class="pl-c1">make</span>(<span class="pl-k">chan</span> <span class="pl-k">int</span>)
    <span class="pl-smi">n</span> <span class="pl-k">:=</span> <span class="pl-c1">1</span>
    <span class="pl-k">go</span> <span class="pl-k">func</span>() {
        <span class="pl-k">for</span> {
            <span class="pl-k">select</span> {
            <span class="pl-k">case</span> <span class="pl-k">&lt;-</span>ctx.<span class="pl-c1">Done</span>():
                <span class="pl-k">return</span> <span class="pl-c"><span class="pl-c">//</span> returning not to leak the goroutine</span>
            <span class="pl-k">case</span> dst <span class="pl-k">&lt;-</span> n:
                n++
            }
        }
    }()
    <span class="pl-k">return</span> dst
}

<span class="pl-k">func</span> <span class="pl-en">main</span>() {
    <span class="pl-smi">ctx</span>, <span class="pl-smi">cancel</span> <span class="pl-k">:=</span> context.<span class="pl-c1">WithCancel</span>(context.<span class="pl-c1">Background</span>())
    <span class="pl-k">defer</span> <span class="pl-c1">cancel</span>() <span class="pl-c"><span class="pl-c">//</span> cancel when we are finished consuming integers</span>

    <span class="pl-k">for</span> <span class="pl-smi">n</span> <span class="pl-k">:=</span> <span class="pl-k">range</span> <span class="pl-c1">gen</span>(ctx) {
        fmt.<span class="pl-c1">Println</span>(n)
        <span class="pl-k">if</span> n == <span class="pl-c1">5</span> {
            <span class="pl-k">break</span>
        }
    }
}
</pre></div>
<h3>
<a id="user-content-实现代码详解" class="anchor" href="#%E5%AE%9E%E7%8E%B0%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>实现代码详解</h3>
<div class="highlight highlight-source-go"><pre><span class="pl-c"><span class="pl-c">//</span> A cancelCtx can be canceled. When canceled, it also cancels any children</span>
<span class="pl-c"><span class="pl-c">//</span> that implement canceler.</span>
<span class="pl-k">type</span> cancelCtx <span class="pl-k">struct</span> {
    <span class="pl-v">Context</span>

    mu       sync.<span class="pl-smi">Mutex</span>            <span class="pl-c"><span class="pl-c">//</span> protects following fields</span>
    done     <span class="pl-k">chan</span> <span class="pl-k">struct</span>{}         <span class="pl-c"><span class="pl-c">//</span> created lazily, closed by first cancel call</span>
    children <span class="pl-k">map</span>[canceler]<span class="pl-k">struct</span>{} <span class="pl-c"><span class="pl-c">//</span> set to nil by the first cancel call</span>
    err      <span class="pl-k">error</span>                 <span class="pl-c"><span class="pl-c">//</span> set to non-nil by the first cancel call</span>
}

<span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">c</span> *<span class="pl-v">cancelCtx</span>) <span class="pl-en">Done</span></span>() &lt;-<span class="pl-v">chan</span> <span class="pl-v">struct</span>{} {
    c.<span class="pl-smi">mu</span>.<span class="pl-c1">Lock</span>()
    <span class="pl-k">if</span> c.<span class="pl-smi">done</span> == <span class="pl-c1">nil</span> {
        c.<span class="pl-smi">done</span> = <span class="pl-c1">make</span>(<span class="pl-k">chan</span> <span class="pl-k">struct</span>{})
    }
    <span class="pl-smi">d</span> <span class="pl-k">:=</span> c.<span class="pl-smi">done</span>
    c.<span class="pl-smi">mu</span>.<span class="pl-c1">Unlock</span>()
    <span class="pl-k">return</span> d
}

<span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">c</span> *<span class="pl-v">cancelCtx</span>) <span class="pl-en">Err</span></span>() <span class="pl-v">error</span> {
    c.<span class="pl-smi">mu</span>.<span class="pl-c1">Lock</span>()
    <span class="pl-k">defer</span> c.<span class="pl-smi">mu</span>.<span class="pl-c1">Unlock</span>()
    <span class="pl-k">return</span> c.<span class="pl-smi">err</span>
}

<span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">c</span> *<span class="pl-v">cancelCtx</span>) <span class="pl-en">String</span></span>() <span class="pl-v">string</span> {
    <span class="pl-k">return</span> fmt.<span class="pl-c1">Sprintf</span>(<span class="pl-s"><span class="pl-pds">"</span><span class="pl-c1">%v</span>.WithCancel<span class="pl-pds">"</span></span>, c.<span class="pl-smi">Context</span>)
}

<span class="pl-c"><span class="pl-c">//</span> cancel closes c.done, cancels each of c's children, and, if</span>
<span class="pl-c"><span class="pl-c">//</span> removeFromParent is true, removes c from its parent's children.</span>
<span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">c</span> *<span class="pl-v">cancelCtx</span>) <span class="pl-en">cancel</span></span>(<span class="pl-v">removeFromParent</span> <span class="pl-v">bool</span>, <span class="pl-v">err</span> <span class="pl-v">error</span>) {
    <span class="pl-k">if</span> err == <span class="pl-c1">nil</span> {
        <span class="pl-c1">panic</span>(<span class="pl-s"><span class="pl-pds">"</span>context: internal error: missing cancel error<span class="pl-pds">"</span></span>)
    }
    c.<span class="pl-smi">mu</span>.<span class="pl-c1">Lock</span>()
    <span class="pl-k">if</span> c.<span class="pl-smi">err</span> != <span class="pl-c1">nil</span> {
        c.<span class="pl-smi">mu</span>.<span class="pl-c1">Unlock</span>()
        <span class="pl-k">return</span> <span class="pl-c"><span class="pl-c">//</span> already canceled</span>
    }
    c.<span class="pl-smi">err</span> = err
    <span class="pl-k">if</span> c.<span class="pl-smi">done</span> == <span class="pl-c1">nil</span> {
        c.<span class="pl-smi">done</span> = closedchan
    } <span class="pl-k">else</span> {
        <span class="pl-c1">close</span>(c.<span class="pl-smi">done</span>)
    }
    <span class="pl-k">for</span> <span class="pl-smi">child</span> <span class="pl-k">:=</span> <span class="pl-k">range</span> c.<span class="pl-smi">children</span> {
        <span class="pl-c"><span class="pl-c">//</span> NOTE: acquiring the child's lock while holding parent's lock.</span>
        child.<span class="pl-c1">cancel</span>(<span class="pl-c1">false</span>, err)
    }
    c.<span class="pl-smi">children</span> = <span class="pl-c1">nil</span>
    c.<span class="pl-smi">mu</span>.<span class="pl-c1">Unlock</span>()

    <span class="pl-k">if</span> removeFromParent {
        <span class="pl-c1">removeChild</span>(c.<span class="pl-smi">Context</span>, c)
    }
}</pre></div>
<h2>
<a id="user-content-context是怎么实现deadline控制的" class="anchor" href="#context%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0deadline%E6%8E%A7%E5%88%B6%E7%9A%84" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>context是怎么实现deadline控制的</h2>
<h3>
<a id="user-content-如何使用-1" class="anchor" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>如何使用</h3>
<pre><code>package main

import (
	"context"
	"fmt"
	"time"
)

func main() {
	d := time.Now().Add(50 * time.Millisecond)
	ctx, cancel := context.WithDeadline(context.Background(), d)
	defer cancel()

	select {
	case &lt;-time.After(1 * time.Second):
		fmt.Println("overslept")
	case &lt;-ctx.Done():
		fmt.Println(ctx.Err(), ctx.Err() == context.DeadlineExceeded)
	}
}
</code></pre>
<h2>
<a id="user-content-简析-1" class="anchor" href="#%E7%AE%80%E6%9E%90-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>简析</h2>
<h3>
<a id="user-content-代码实现详解" class="anchor" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>代码实现详解</h3>
<p>withvalue 不能跨服务（grpc特有？）
metadata，</p>
<p>有in和out，client是out，server是in</p>
<h2>
<a id="user-content-context-控制" class="anchor" href="#context-%E6%8E%A7%E5%88%B6" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>context 控制</h2>
<h2>
<a id="user-content-参考文章" class="anchor" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>参考文章</h2>
<ul>
<li><a href="https://github.com/grpc/grpc-go/issues/156">https://github.com/grpc/grpc-go/issues/156</a></li>
<li><a href="https://talks.golang.org/2014/gotham-context.slide#1" rel="nofollow">https://talks.golang.org/2014/gotham-context.slide#1</a></li>
</ul>


</div>

</body>
</html>
