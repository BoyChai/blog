
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Begin Jekyll SEO tag v2.3.0 -->
    <title>chyroc.github.io | 基于issues的个人博客</title>
    <meta property="og:title" content="chyroc.github.io"/>
    <meta property="og:locale" content="en_US"/>
    <meta name="description" content="基于issues的个人博客"/>
    <meta property="og:description" content="基于issues的个人博客"/>
    <link rel="canonical" href="http://blog.chyroc.cn/articles/some.html"/>
    <meta property="og:url" content="http://blog.chyroc.cn/articles/some.html"/>
    <meta property="og:site_name" content="chyroc.github.io"/>
    <script type="application/ld+json">
        {"name":null,"description":"基于issues的个人博客","author":null,"@type":"WebPage","url":"http://blog.chyroc.cn/articles/some.html","image":null,"publisher":null,"headline":"chyroc.github.io","dateModified":null,"datePublished":null,"sameAs":null,"mainEntityOfPage":null,"@context":"http://schema.org"}
    </script>
    <!-- End Jekyll SEO tag -->

    <link href="http://blog.chyroc.cn/assets/css/style.css?v=efb62de7b7525b6b14733e28358121421ac29cfd" rel="stylesheet">
</head>

<body>
<div class="container-lg px-3 my-5 markdown-body">
    <h1><a href="http://blog.chyroc.cn/">chyroc.github.io</a></h1>
<p>目前做的一个业务涉及到<code>websocket</code>，在这里记录下来，虽然还不知道那个pr会不会过。</p>
<p>整个业务可以概括为：</p>
<blockquote>
<p>涉及到三端：前端、后端和第三方服务商</p>
</blockquote>
<blockquote>
<p>前端发起一个请求，会产生一个 <code>op_id</code></p>
</blockquote>
<blockquote>
<p>第三方服务商在这个请求过程中，会不断<code>post</code>数据到后端提供的回调地址上</p>
</blockquote>
<blockquote>
<p>后端需要把这些信息以<code>websocket</code>的方式提供给前端，以做好交互</p>
</blockquote>
<p>我大概想了一下，需要处理这么几个问题</p>
<ul>
<li>用户验证（指<code>websocket</code>端的）</li>
<li>绑定用户和<code>op_id</code>，使得<code>websocket</code>消息可以到达指定用户</li>
<li>打开多个窗口，怎么保证收到的消息是一样的（同步）</li>
<li>数据怎么从回调 <code>goroutine</code>传递到另外一个<code>websocket goroutine</code>内</li>
</ul>
<h3>
<a id="user-content-用户验证" class="anchor" href="#%E7%94%A8%E6%88%B7%E9%AA%8C%E8%AF%81" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>用户验证</h3>
<p><code>websocket</code>首先使用一个<code>get</code>请求建立连接，然后不再断开，可以在建立连接的时候进行身份认证</p>
<div class="highlight highlight-source-json"><pre>{
    <span class="pl-s"><span class="pl-pds">"</span>method<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>GET<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>path<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>/websocket/:access_token<span class="pl-pds">"</span></span>,
    <span class="pl-s"><span class="pl-pds">"</span>request<span class="pl-pds">"</span></span>: <span class="pl-s"><span class="pl-pds">"</span>GET /websocket/........ HTTP/1.1......Connection: Upgrade.....Upgrade: websocket.....<span class="pl-pds">"</span></span>
  }</pre></div>
<h3>
<a id="user-content-数据绑定" class="anchor" href="#%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>数据绑定</h3>
<p>我使用的方法是在前端<code>前端发起一个请求，会产生一个 op_id</code>的时候，将<code>op_id</code>和<code>user_id</code>存在redis里面</p>
<p>没有存变量/channel 是因为需要保证在一个通话过程中，重启服务端不会清除数据</p>
<h3>
<a id="user-content-多终端消息一致" class="anchor" href="#%E5%A4%9A%E7%BB%88%E7%AB%AF%E6%B6%88%E6%81%AF%E4%B8%80%E8%87%B4" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>多终端消息一致</h3>
<p>使用全局变量clients存储连接，对于同一user的多个终端，遍历存起来的链接，每个都进行消息发送。</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">HandlerWebsocket</span>(<span class="pl-v">w</span> <span class="pl-v">http</span>.<span class="pl-v">ResponseWriter</span>, <span class="pl-v">r</span> *<span class="pl-v">http</span>.<span class="pl-v">Request</span>) {
  <span class="pl-c"><span class="pl-c">//</span> ... some code</span>

	clients.<span class="pl-c1">Add</span>(user, c)
	<span class="pl-k">defer</span> clients.<span class="pl-c1">Delete</span>(userKey, c)

	<span class="pl-k">for</span> {
		<span class="pl-k">if</span> <span class="pl-smi">v</span>, <span class="pl-smi">ok</span> <span class="pl-k">:=</span> message[user]; ok {
			<span class="pl-smi">message</span> <span class="pl-k">:=</span> <span class="pl-k">&lt;-</span>v

			<span class="pl-smi">cls</span> <span class="pl-k">:=</span> clients.<span class="pl-c1">Get</span>(user)
			<span class="pl-k">for</span> <span class="pl-smi">conn</span>, <span class="pl-smi">_</span> <span class="pl-k">:=</span> <span class="pl-k">range</span> cls { <span class="pl-c"><span class="pl-c">//</span> 这里有循环对同一用户进行消息广播</span>
				conn.<span class="pl-c1">WriteJSON</span>(message)
			}
		}
	}
}</pre></div>
<p>这是存储用户和链接的数据结构（简化版）。</p>
<p>这里有一个问题，指针可以作为key，而<code>websocket.Conn</code>不行，原因忘了，原来有一次看到过。</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">map</span>[<span class="pl-k">string</span>]<span class="pl-k">map</span>[*websocket.<span class="pl-smi">Conn</span>]<span class="pl-k">bool</span></pre></div>
<h3>
<a id="user-content-goroutine间数据传递" class="anchor" href="#goroutine%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>goroutine间数据传递</h3>
<p>使用channel</p>
<div class="highlight highlight-source-go"><pre><span class="pl-k">var</span> <span class="pl-smi">message</span> = <span class="pl-c1">make</span>(<span class="pl-k">map</span>[<span class="pl-k">string</span>](<span class="pl-k">chan</span> <span class="pl-k">map</span>[<span class="pl-k">string</span>]<span class="pl-k">interface</span>{}))

<span class="pl-k">func</span> <span class="pl-en">HandlerCallback</span>(<span class="pl-v">body</span> <span class="pl-v">CallbackBody</span>) (<span class="pl-v">int</span>, <span class="pl-v">string</span>) {
	<span class="pl-c"><span class="pl-c">//</span> ... some code</span>

	message[user] <span class="pl-k">&lt;-</span> body

	<span class="pl-c"><span class="pl-c">//</span> ... some code</span>
}

<span class="pl-c"><span class="pl-c">//</span> 使用见前一小节</span></pre></div>

    <div id="disqus_thread"></div>
    <script>

      /**
       *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
       *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
      /*
       var disqus_config = function () {
       this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
       this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
       };
       */
      (function () { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script')
        s.src = 'https://chyroc.disqus.com/embed.js'
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s)
      })()
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by
        Disqus.</a></noscript>
    <script id="dsq-count-scr" src="//chyroc.disqus.com/count.js" async></script>
</div>
</body>

</html>
