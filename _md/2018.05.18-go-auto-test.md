# go中的自动测试

- time 2018-05-18


## 前言

最近在做leetcode的题目，需要搞一些简单的测试代码，但是测试函数的输入输出的描述、判断函数是否成功比较麻烦

所以我就在想，能不能我定义一个input和一个output，能够自动的将input转成go的代码，然后执行测试函数之后，比较返回值和output是否一致

要想这么做，肯定需要使用到反射，并且需要定义一下怎么从字符串转化到go的代码

## parse字符串定义

* 用逗号分隔数组的各个元素
* 用\n分隔多个输入或者多个输出
* [1,2,3] 定义slice
* {a: b} 定义map
* slice或者map中的子元素的类型要看函数定义参数的类型

## 代码解析

### parseParam 这里需要自定义string转化

参数是string / reflect.Type，返回值是reflect.Value

主要是tring to int,bool,slice,map，并转成reflect.Value的类型
```go
func parseParam(t *testing.T, param string, typ reflect.Type) reflect.Value {
	var r reflect.Value
	var as = assert.New(t)
	param = strings.TrimSpace(param)

	switch typ.Kind() {
	case reflect.Int:
		i, err := strconv.Atoi(param)
		as.Nil(err)
		r = reflect.ValueOf(i)
	case reflect.String:
		r = reflect.ValueOf(param)
	case reflect.Bool:
		b, err := strconv.ParseBool(param)
		as.Nil(err)
		r = reflect.ValueOf(b)
	case reflect.Slice:
		as.True(len(param) > 1)
		as.True(strings.HasPrefix(param, "["))
		as.True(strings.HasSuffix(param, "]"))
		param = strings.TrimPrefix(param, "[")
		param = strings.TrimSuffix(param, "]")
		s2 := strings.Split(param, ",")

		r = reflect.MakeSlice(reflect.SliceOf(typ.Elem()), 0, 0)
		for _, v := range s2 {
			r = reflect.Append(r, parseParam(t, v, typ.Elem()))
		}
	default:
		panic(fmt.Sprintf("not support %s", typ.Kind()))
	}

	return r
}
```

### 输入参数解析

```go
ft := reflect.TypeOf(Func)
fv := reflect.ValueOf(Func)
```

然后遍历reflect.TypeOf(Func).In(i)，这个是输入参数的类型

将输入参数字符串转成对应类型的go代码：ithParamIn := parseParam(t, input[i], ithCallInType)

```go
var in []reflect.Value
for i := 0; i < ft.NumIn(); i++ {
	ithCallInType := ft.In(i)

	ithParamIn := parseParam(t, input[i], ithCallInType)

	in = append(in, ithParamIn)
}
```

### 执行测试函数

```go
out := fv.Call(in)
```

这边的out是一个[]reflect.Value，需要将他和函数签名，以及给定的输出的字符串进行比较

### 输出参数解析和验证

out 有三个，call返回，ft.Out(i)的，output的

```go
for i := 0; i < ft.NumOut(); i++ {
	ithCallRealOut := out[i] // 比input多的
	ithCallOutType := ft.Out(i)
	ithCallOut := parseParam(t, output[i], ithCallOutType)

	as.Equal(ithCallOut.Kind(), ithCallRealOut.Kind())
	as.Equal(ithCallOut.Kind(), ithCallRealOut.Convert(ithCallOutType).Kind())
	as.Equal(ithCallOut.Interface(), ithCallRealOut.Convert(ithCallOutType).Interface())
}
```

## 所以看看这怎么用

可以看到只要给了input和output的字符串，和要测试的函数，那么就能通过反射自动解析参数，执行测试代码，并看看是不是给定的输出

```go
func TestRunCase(t *testing.T) {
	t.Run("(int)->int", func(t *testing.T) {
		Runs(t, func(a int) int { return a + 1 }, []*Case{
			{Input: `1`, Output: "2"},
			{Input: `999`, Output: "1000"},
		})
	})

	t.Run("(int,int)->int", func(t *testing.T) {
		Runs(t, func(a, b int) int { return a + b }, []*Case{
			{Input: `1\n2`, Output: "3"},
		})
	})

	t.Run("(string)->string", func(t *testing.T) {
		Runs(t, func(a string) string { return a + "1" }, []*Case{
			{Input: "a", Output: "a1"},
		})
	})

	t.Run("(int)->bool", func(t *testing.T) {
		Runs(t, func(i int) bool { return i < 10 }, []*Case{
			{Input: "1", Output: "true"},
			{Input: "10", Output: "false"},
		})
	})

	t.Run("(string,string)->string", func(t *testing.T) {
		Runs(t, func(a, b string) string { return a + b }, []*Case{
			{Input: `a\nb`, Output: "ab"},
		})
	})

	t.Run("(list<int>)->bool", func(t *testing.T) {
		Runs(t, func(s []int) bool { return len(s) > 2 }, []*Case{
			{Input: `[1,2,3]`, Output: "true"},
			{Input: `[1]`, Output: "false"},
		})
	})
}
```

## 代码（[地址](https://github.com/Chyroc/algorithms-go/blob/master/test/run_case.go)）
```go
package test

import (
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

type Case struct {
	Func   interface{}
	Input  string
	Output string
}

func Runs(t *testing.T, f interface{}, cs []*Case) {
	for _, c := range cs {
		Run(t, &Case{
			Func:   f,
			Input:  c.Input,
			Output: c.Output,
		})
	}
}

// parseParam 这里需要自定义string转化
//
// 参数是string / reflect.Type，返回值是reflect.Value
// string(1), int => int(1)
// string([1,2,3]), slice(int) => []int{1,2,3}
func parseParam(t *testing.T, param string, typ reflect.Type) reflect.Value {
	var r reflect.Value
	var as = assert.New(t)
	param = strings.TrimSpace(param)

	switch typ.Kind() {
	case reflect.Int:
		i, err := strconv.Atoi(param)
		as.Nil(err)
		r = reflect.ValueOf(i)
	case reflect.String:
		r = reflect.ValueOf(param)
	case reflect.Bool:
		b, err := strconv.ParseBool(param)
		as.Nil(err)
		r = reflect.ValueOf(b)
	case reflect.Slice:
		as.True(len(param) > 1)
		as.True(strings.HasPrefix(param, "["))
		as.True(strings.HasSuffix(param, "]"))
		param = strings.TrimPrefix(param, "[")
		param = strings.TrimSuffix(param, "]")
		s2 := strings.Split(param, ",")

		r = reflect.MakeSlice(reflect.SliceOf(typ.Elem()), 0, 0)
		for _, v := range s2 {
			r = reflect.Append(r, parseParam(t, v, typ.Elem()))
		}
	default:
		panic(fmt.Sprintf("not support %s", typ.Kind()))
	}

	return r
}

func Run(t *testing.T, c *Case) {
	as := assert.New(t)
	input := strings.Split(strings.TrimSpace(c.Input), `\n`)
	output := strings.Split(strings.TrimSpace(c.Output), `\n`)

	ft := reflect.TypeOf(c.Func)
	fv := reflect.ValueOf(c.Func)
	as.Equal(reflect.Func, ft.Kind())
	as.Equal(reflect.Func, fv.Kind())
	as.Len(input, ft.NumIn())
	as.Len(output, ft.NumOut())

	var in []reflect.Value
	for i := 0; i < ft.NumIn(); i++ {
		ithCallInType := ft.In(i)

		ithParamIn := parseParam(t, input[i], ithCallInType)

		in = append(in, ithParamIn)
	}

	out := fv.Call(in)

	// out 有三个，call返回，ft.Out(i)的，output的
	for i := 0; i < ft.NumOut(); i++ {
		ithCallRealOut := out[i] // 比input多的
		ithCallOutType := ft.Out(i)
		ithCallOut := parseParam(t, output[i], ithCallOutType)

		as.Equal(ithCallOut.Kind(), ithCallRealOut.Kind())
		as.Equal(ithCallOut.Kind(), ithCallRealOut.Convert(ithCallOutType).Kind())
		as.Equal(ithCallOut.Interface(), ithCallRealOut.Convert(ithCallOutType).Interface())
	}
}
```